// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_site_commands

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func SiteCommandsResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"command": schema.StringAttribute{
				Required:            true,
				Description:         "The command to run.",
				MarkdownDescription: "The command to run.",
			},
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"attributes": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"command": schema.StringAttribute{
								Computed:            true,
								Description:         "The command that ran.",
								MarkdownDescription: "The command that ran.",
							},
							"created_at": schema.StringAttribute{
								Computed:            true,
								Description:         "The date and time the command was created.",
								MarkdownDescription: "The date and time the command was created.",
							},
							"duration": schema.StringAttribute{
								Computed:            true,
								Description:         "The duration of the command in human-readable format.",
								MarkdownDescription: "The duration of the command in human-readable format.",
							},
							"opcache_enabled": schema.BoolAttribute{
								Computed: true,
							},
							"status": schema.StringAttribute{
								Computed: true,
							},
							"updated_at": schema.StringAttribute{
								Computed:            true,
								Description:         "The date and time the command was last updated.",
								MarkdownDescription: "The date and time the command was last updated.",
							},
							"user_id": schema.Int64Attribute{
								Computed:            true,
								Description:         "The ID of the user who initiated the command.",
								MarkdownDescription: "The ID of the user who initiated the command.",
							},
						},
						CustomType: AttributesType{
							ObjectType: types.ObjectType{
								AttrTypes: AttributesValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"links": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"self": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"describedby": schema.StringAttribute{
										Computed: true,
									},
									"href": schema.StringAttribute{
										Computed: true,
									},
									"hreflang": schema.StringAttribute{
										Computed:            true,
										Description:         "Language of the target link",
										MarkdownDescription: "Language of the target link",
									},
									"meta": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{},
										CustomType: MetaType{
											ObjectType: types.ObjectType{
												AttrTypes: MetaValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"rel": schema.StringAttribute{
										Computed: true,
									},
									"title": schema.StringAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: SelfType{
									ObjectType: types.ObjectType{
										AttrTypes: SelfValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
						},
						CustomType: LinksType{
							ObjectType: types.ObjectType{
								AttrTypes: LinksValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"relationships": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"user": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"data": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"id": schema.StringAttribute{
												Computed: true,
											},
											"type": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: DataType{
											ObjectType: types.ObjectType{
												AttrTypes: DataValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
								},
								CustomType: UserType{
									ObjectType: types.ObjectType{
										AttrTypes: UserValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "The user who initiated the command.",
								MarkdownDescription: "The user who initiated the command.",
							},
						},
						CustomType: RelationshipsType{
							ObjectType: types.ObjectType{
								AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"type": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"organization": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The organization slug",
				MarkdownDescription: "The organization slug",
			},
			"server": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The server ID",
				MarkdownDescription: "The server ID",
			},
			"site": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The site ID",
				MarkdownDescription: "The site ID",
			},
		},
	}
}

type SiteCommandsModel struct {
	Command      types.String `tfsdk:"command"`
	Data         DataValue    `tfsdk:"data"`
	Organization types.String `tfsdk:"organization"`
	Server       types.Int64  `tfsdk:"server"`
	Site         types.Int64  `tfsdk:"site"`
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return nil, diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.ObjectValue, was: %T`, attributesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return nil, diags
	}

	linksVal, ok := linksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ObjectValue, was: %T`, linksAttribute))
	}

	relationshipsAttribute, ok := attributes["relationships"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`relationships is missing from object`)

		return nil, diags
	}

	relationshipsVal, ok := relationshipsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`relationships expected to be basetypes.ObjectValue, was: %T`, relationshipsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Attributes:    attributesVal,
		Id:            idVal,
		Links:         linksVal,
		Relationships: relationshipsVal,
		DataType:      typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return NewDataValueUnknown(), diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.ObjectValue, was: %T`, attributesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return NewDataValueUnknown(), diags
	}

	linksVal, ok := linksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ObjectValue, was: %T`, linksAttribute))
	}

	relationshipsAttribute, ok := attributes["relationships"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`relationships is missing from object`)

		return NewDataValueUnknown(), diags
	}

	relationshipsVal, ok := relationshipsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`relationships expected to be basetypes.ObjectValue, was: %T`, relationshipsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Attributes:    attributesVal,
		Id:            idVal,
		Links:         linksVal,
		Relationships: relationshipsVal,
		DataType:      typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Attributes    basetypes.ObjectValue `tfsdk:"attributes"`
	Id            basetypes.StringValue `tfsdk:"id"`
	Links         basetypes.ObjectValue `tfsdk:"links"`
	Relationships basetypes.ObjectValue `tfsdk:"relationships"`
	DataType      basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["attributes"] = basetypes.ObjectType{
		AttrTypes: AttributesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["links"] = basetypes.ObjectType{
		AttrTypes: LinksValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["relationships"] = basetypes.ObjectType{
		AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Attributes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attributes"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Links.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["links"] = val

		val, err = v.Relationships.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["relationships"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attributes basetypes.ObjectValue

	if v.Attributes.IsNull() {
		attributes = types.ObjectNull(
			AttributesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Attributes.IsUnknown() {
		attributes = types.ObjectUnknown(
			AttributesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Attributes.IsNull() && !v.Attributes.IsUnknown() {
		attributes = types.ObjectValueMust(
			AttributesValue{}.AttributeTypes(ctx),
			v.Attributes.Attributes(),
		)
	}

	var links basetypes.ObjectValue

	if v.Links.IsNull() {
		links = types.ObjectNull(
			LinksValue{}.AttributeTypes(ctx),
		)
	}

	if v.Links.IsUnknown() {
		links = types.ObjectUnknown(
			LinksValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Links.IsNull() && !v.Links.IsUnknown() {
		links = types.ObjectValueMust(
			LinksValue{}.AttributeTypes(ctx),
			v.Links.Attributes(),
		)
	}

	var relationships basetypes.ObjectValue

	if v.Relationships.IsNull() {
		relationships = types.ObjectNull(
			RelationshipsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Relationships.IsUnknown() {
		relationships = types.ObjectUnknown(
			RelationshipsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Relationships.IsNull() && !v.Relationships.IsUnknown() {
		relationships = types.ObjectValueMust(
			RelationshipsValue{}.AttributeTypes(ctx),
			v.Relationships.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"attributes": basetypes.ObjectType{
			AttrTypes: AttributesValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"links": basetypes.ObjectType{
			AttrTypes: LinksValue{}.AttributeTypes(ctx),
		},
		"relationships": basetypes.ObjectType{
			AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attributes":    attributes,
			"id":            v.Id,
			"links":         links,
			"relationships": relationships,
			"type":          v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Attributes.Equal(other.Attributes) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Links.Equal(other.Links) {
		return false
	}

	if !v.Relationships.Equal(other.Relationships) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attributes": basetypes.ObjectType{
			AttrTypes: AttributesValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"links": basetypes.ObjectType{
			AttrTypes: LinksValue{}.AttributeTypes(ctx),
		},
		"relationships": basetypes.ObjectType{
			AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttributesType{}

type AttributesType struct {
	basetypes.ObjectType
}

func (t AttributesType) Equal(o attr.Type) bool {
	other, ok := o.(AttributesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttributesType) String() string {
	return "AttributesType"
}

func (t AttributesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	commandAttribute, ok := attributes["command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`command is missing from object`)

		return nil, diags
	}

	commandVal, ok := commandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`command expected to be basetypes.StringValue, was: %T`, commandAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return nil, diags
	}

	durationVal, ok := durationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.StringValue, was: %T`, durationAttribute))
	}

	opcacheEnabledAttribute, ok := attributes["opcache_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`opcache_enabled is missing from object`)

		return nil, diags
	}

	opcacheEnabledVal, ok := opcacheEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`opcache_enabled expected to be basetypes.BoolValue, was: %T`, opcacheEnabledAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	userIdAttribute, ok := attributes["user_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_id is missing from object`)

		return nil, diags
	}

	userIdVal, ok := userIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_id expected to be basetypes.Int64Value, was: %T`, userIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttributesValue{
		Command:        commandVal,
		CreatedAt:      createdAtVal,
		Duration:       durationVal,
		OpcacheEnabled: opcacheEnabledVal,
		Status:         statusVal,
		UpdatedAt:      updatedAtVal,
		UserId:         userIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueNull() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateNull,
	}
}

func NewAttributesValueUnknown() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAttributesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttributesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttributesValue Attribute Value",
				"While creating a AttributesValue value, a missing attribute value was detected. "+
					"A AttributesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttributesValue Attribute Type",
				"While creating a AttributesValue value, an invalid attribute value was detected. "+
					"A AttributesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttributesValue Attribute Value",
				"While creating a AttributesValue value, an extra attribute value was detected. "+
					"A AttributesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttributesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	commandAttribute, ok := attributes["command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`command is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	commandVal, ok := commandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`command expected to be basetypes.StringValue, was: %T`, commandAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	durationVal, ok := durationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.StringValue, was: %T`, durationAttribute))
	}

	opcacheEnabledAttribute, ok := attributes["opcache_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`opcache_enabled is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	opcacheEnabledVal, ok := opcacheEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`opcache_enabled expected to be basetypes.BoolValue, was: %T`, opcacheEnabledAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	userIdAttribute, ok := attributes["user_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_id is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	userIdVal, ok := userIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_id expected to be basetypes.Int64Value, was: %T`, userIdAttribute))
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	return AttributesValue{
		Command:        commandVal,
		CreatedAt:      createdAtVal,
		Duration:       durationVal,
		OpcacheEnabled: opcacheEnabledVal,
		Status:         statusVal,
		UpdatedAt:      updatedAtVal,
		UserId:         userIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttributesValue {
	object, diags := NewAttributesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttributesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttributesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttributesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttributesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttributesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttributesValueMust(AttributesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AttributesType) ValueType(ctx context.Context) attr.Value {
	return AttributesValue{}
}

var _ basetypes.ObjectValuable = AttributesValue{}

type AttributesValue struct {
	Command        basetypes.StringValue `tfsdk:"command"`
	CreatedAt      basetypes.StringValue `tfsdk:"created_at"`
	Duration       basetypes.StringValue `tfsdk:"duration"`
	OpcacheEnabled basetypes.BoolValue   `tfsdk:"opcache_enabled"`
	Status         basetypes.StringValue `tfsdk:"status"`
	UpdatedAt      basetypes.StringValue `tfsdk:"updated_at"`
	UserId         basetypes.Int64Value  `tfsdk:"user_id"`
	state          attr.ValueState
}

func (v AttributesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["duration"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["opcache_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Command.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["command"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Duration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duration"] = val

		val, err = v.OpcacheEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["opcache_enabled"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		val, err = v.UserId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttributesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttributesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttributesValue) String() string {
	return "AttributesValue"
}

func (v AttributesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"command":         basetypes.StringType{},
		"created_at":      basetypes.StringType{},
		"duration":        basetypes.StringType{},
		"opcache_enabled": basetypes.BoolType{},
		"status":          basetypes.StringType{},
		"updated_at":      basetypes.StringType{},
		"user_id":         basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"command":         v.Command,
			"created_at":      v.CreatedAt,
			"duration":        v.Duration,
			"opcache_enabled": v.OpcacheEnabled,
			"status":          v.Status,
			"updated_at":      v.UpdatedAt,
			"user_id":         v.UserId,
		})

	return objVal, diags
}

func (v AttributesValue) Equal(o attr.Value) bool {
	other, ok := o.(AttributesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Command.Equal(other.Command) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Duration.Equal(other.Duration) {
		return false
	}

	if !v.OpcacheEnabled.Equal(other.OpcacheEnabled) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	if !v.UserId.Equal(other.UserId) {
		return false
	}

	return true
}

func (v AttributesValue) Type(ctx context.Context) attr.Type {
	return AttributesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttributesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"command":         basetypes.StringType{},
		"created_at":      basetypes.StringType{},
		"duration":        basetypes.StringType{},
		"opcache_enabled": basetypes.BoolType{},
		"status":          basetypes.StringType{},
		"updated_at":      basetypes.StringType{},
		"user_id":         basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LinksType{}

type LinksType struct {
	basetypes.ObjectType
}

func (t LinksType) Equal(o attr.Type) bool {
	other, ok := o.(LinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinksType) String() string {
	return "LinksType"
}

func (t LinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return nil, diags
	}

	selfVal, ok := selfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.ObjectValue, was: %T`, selfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinksValue{
		Self:  selfVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLinksValueNull() LinksValue {
	return LinksValue{
		state: attr.ValueStateNull,
	}
}

func NewLinksValueUnknown() LinksValue {
	return LinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinksValue Attribute Value",
				"While creating a LinksValue value, a missing attribute value was detected. "+
					"A LinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinksValue Attribute Type",
				"While creating a LinksValue value, an invalid attribute value was detected. "+
					"A LinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinksValue Attribute Value",
				"While creating a LinksValue value, an extra attribute value was detected. "+
					"A LinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	selfVal, ok := selfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.ObjectValue, was: %T`, selfAttribute))
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	return LinksValue{
		Self:  selfVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinksValue {
	object, diags := NewLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinksValueMust(LinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinksType) ValueType(ctx context.Context) attr.Value {
	return LinksValue{}
}

var _ basetypes.ObjectValuable = LinksValue{}

type LinksValue struct {
	Self  basetypes.ObjectValue `tfsdk:"self"`
	state attr.ValueState
}

func (v LinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["self"] = basetypes.ObjectType{
		AttrTypes: SelfValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Self.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["self"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinksValue) String() string {
	return "LinksValue"
}

func (v LinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var self basetypes.ObjectValue

	if v.Self.IsNull() {
		self = types.ObjectNull(
			SelfValue{}.AttributeTypes(ctx),
		)
	}

	if v.Self.IsUnknown() {
		self = types.ObjectUnknown(
			SelfValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Self.IsNull() && !v.Self.IsUnknown() {
		self = types.ObjectValueMust(
			SelfValue{}.AttributeTypes(ctx),
			v.Self.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"self": basetypes.ObjectType{
			AttrTypes: SelfValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"self": self,
		})

	return objVal, diags
}

func (v LinksValue) Equal(o attr.Value) bool {
	other, ok := o.(LinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Self.Equal(other.Self) {
		return false
	}

	return true
}

func (v LinksValue) Type(ctx context.Context) attr.Type {
	return LinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"self": basetypes.ObjectType{
			AttrTypes: SelfValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SelfType{}

type SelfType struct {
	basetypes.ObjectType
}

func (t SelfType) Equal(o attr.Type) bool {
	other, ok := o.(SelfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SelfType) String() string {
	return "SelfType"
}

func (t SelfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	describedbyAttribute, ok := attributes["describedby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`describedby is missing from object`)

		return nil, diags
	}

	describedbyVal, ok := describedbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`describedby expected to be basetypes.StringValue, was: %T`, describedbyAttribute))
	}

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return nil, diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	hreflangAttribute, ok := attributes["hreflang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hreflang is missing from object`)

		return nil, diags
	}

	hreflangVal, ok := hreflangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hreflang expected to be basetypes.StringValue, was: %T`, hreflangAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return nil, diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return nil, diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return nil, diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SelfValue{
		Describedby: describedbyVal,
		Href:        hrefVal,
		Hreflang:    hreflangVal,
		Meta:        metaVal,
		Rel:         relVal,
		Title:       titleVal,
		SelfType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSelfValueNull() SelfValue {
	return SelfValue{
		state: attr.ValueStateNull,
	}
}

func NewSelfValueUnknown() SelfValue {
	return SelfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSelfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SelfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SelfValue Attribute Value",
				"While creating a SelfValue value, a missing attribute value was detected. "+
					"A SelfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SelfValue Attribute Type",
				"While creating a SelfValue value, an invalid attribute value was detected. "+
					"A SelfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SelfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SelfValue Attribute Value",
				"While creating a SelfValue value, an extra attribute value was detected. "+
					"A SelfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SelfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSelfValueUnknown(), diags
	}

	describedbyAttribute, ok := attributes["describedby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`describedby is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	describedbyVal, ok := describedbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`describedby expected to be basetypes.StringValue, was: %T`, describedbyAttribute))
	}

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	hreflangAttribute, ok := attributes["hreflang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hreflang is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	hreflangVal, ok := hreflangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hreflang expected to be basetypes.StringValue, was: %T`, hreflangAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSelfValueUnknown(), diags
	}

	return SelfValue{
		Describedby: describedbyVal,
		Href:        hrefVal,
		Hreflang:    hreflangVal,
		Meta:        metaVal,
		Rel:         relVal,
		Title:       titleVal,
		SelfType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSelfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SelfValue {
	object, diags := NewSelfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSelfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SelfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSelfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSelfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSelfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSelfValueMust(SelfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SelfType) ValueType(ctx context.Context) attr.Value {
	return SelfValue{}
}

var _ basetypes.ObjectValuable = SelfValue{}

type SelfValue struct {
	Describedby basetypes.StringValue `tfsdk:"describedby"`
	Href        basetypes.StringValue `tfsdk:"href"`
	Hreflang    basetypes.StringValue `tfsdk:"hreflang"`
	Meta        basetypes.ObjectValue `tfsdk:"meta"`
	Rel         basetypes.StringValue `tfsdk:"rel"`
	Title       basetypes.StringValue `tfsdk:"title"`
	SelfType    basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v SelfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["describedby"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["href"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hreflang"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["meta"] = basetypes.ObjectType{
		AttrTypes: MetaValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["rel"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["title"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Describedby.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["describedby"] = val

		val, err = v.Href.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["href"] = val

		val, err = v.Hreflang.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hreflang"] = val

		val, err = v.Meta.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["meta"] = val

		val, err = v.Rel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rel"] = val

		val, err = v.Title.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["title"] = val

		val, err = v.SelfType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SelfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SelfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SelfValue) String() string {
	return "SelfValue"
}

func (v SelfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var meta basetypes.ObjectValue

	if v.Meta.IsNull() {
		meta = types.ObjectNull(
			MetaValue{}.AttributeTypes(ctx),
		)
	}

	if v.Meta.IsUnknown() {
		meta = types.ObjectUnknown(
			MetaValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Meta.IsNull() && !v.Meta.IsUnknown() {
		meta = types.ObjectValueMust(
			MetaValue{}.AttributeTypes(ctx),
			v.Meta.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"describedby": basetypes.StringType{},
		"href":        basetypes.StringType{},
		"hreflang":    basetypes.StringType{},
		"meta": basetypes.ObjectType{
			AttrTypes: MetaValue{}.AttributeTypes(ctx),
		},
		"rel":   basetypes.StringType{},
		"title": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"describedby": v.Describedby,
			"href":        v.Href,
			"hreflang":    v.Hreflang,
			"meta":        meta,
			"rel":         v.Rel,
			"title":       v.Title,
			"type":        v.SelfType,
		})

	return objVal, diags
}

func (v SelfValue) Equal(o attr.Value) bool {
	other, ok := o.(SelfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Describedby.Equal(other.Describedby) {
		return false
	}

	if !v.Href.Equal(other.Href) {
		return false
	}

	if !v.Hreflang.Equal(other.Hreflang) {
		return false
	}

	if !v.Meta.Equal(other.Meta) {
		return false
	}

	if !v.Rel.Equal(other.Rel) {
		return false
	}

	if !v.Title.Equal(other.Title) {
		return false
	}

	if !v.SelfType.Equal(other.SelfType) {
		return false
	}

	return true
}

func (v SelfValue) Type(ctx context.Context) attr.Type {
	return SelfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SelfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"describedby": basetypes.StringType{},
		"href":        basetypes.StringType{},
		"hreflang":    basetypes.StringType{},
		"meta": basetypes.ObjectType{
			AttrTypes: MetaValue{}.AttributeTypes(ctx),
		},
		"rel":   basetypes.StringType{},
		"title": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MetaType{}

type MetaType struct {
	basetypes.ObjectType
}

func (t MetaType) Equal(o attr.Type) bool {
	other, ok := o.(MetaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetaType) String() string {
	return "MetaType"
}

func (t MetaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return MetaValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewMetaValueNull() MetaValue {
	return MetaValue{
		state: attr.ValueStateNull,
	}
}

func NewMetaValueUnknown() MetaValue {
	return MetaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetaValue Attribute Value",
				"While creating a MetaValue value, a missing attribute value was detected. "+
					"A MetaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetaValue Attribute Type",
				"While creating a MetaValue value, an invalid attribute value was detected. "+
					"A MetaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetaValue Attribute Value",
				"While creating a MetaValue value, an extra attribute value was detected. "+
					"A MetaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	return MetaValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewMetaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetaValue {
	object, diags := NewMetaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetaValueMust(MetaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetaType) ValueType(ctx context.Context) attr.Value {
	return MetaValue{}
}

var _ basetypes.ObjectValuable = MetaValue{}

type MetaValue struct {
	state attr.ValueState
}

func (v MetaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetaValue) String() string {
	return "MetaValue"
}

func (v MetaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v MetaValue) Equal(o attr.Value) bool {
	other, ok := o.(MetaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v MetaValue) Type(ctx context.Context) attr.Type {
	return MetaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = RelationshipsType{}

type RelationshipsType struct {
	basetypes.ObjectType
}

func (t RelationshipsType) Equal(o attr.Type) bool {
	other, ok := o.(RelationshipsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RelationshipsType) String() string {
	return "RelationshipsType"
}

func (t RelationshipsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.ObjectValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RelationshipsValue{
		User:  userVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRelationshipsValueNull() RelationshipsValue {
	return RelationshipsValue{
		state: attr.ValueStateNull,
	}
}

func NewRelationshipsValueUnknown() RelationshipsValue {
	return RelationshipsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRelationshipsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RelationshipsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RelationshipsValue Attribute Value",
				"While creating a RelationshipsValue value, a missing attribute value was detected. "+
					"A RelationshipsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RelationshipsValue Attribute Type",
				"While creating a RelationshipsValue value, an invalid attribute value was detected. "+
					"A RelationshipsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RelationshipsValue Attribute Value",
				"While creating a RelationshipsValue value, an extra attribute value was detected. "+
					"A RelationshipsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RelationshipsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRelationshipsValueUnknown(), diags
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewRelationshipsValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.ObjectValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return NewRelationshipsValueUnknown(), diags
	}

	return RelationshipsValue{
		User:  userVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRelationshipsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RelationshipsValue {
	object, diags := NewRelationshipsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRelationshipsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RelationshipsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRelationshipsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRelationshipsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRelationshipsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRelationshipsValueMust(RelationshipsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RelationshipsType) ValueType(ctx context.Context) attr.Value {
	return RelationshipsValue{}
}

var _ basetypes.ObjectValuable = RelationshipsValue{}

type RelationshipsValue struct {
	User  basetypes.ObjectValue `tfsdk:"user"`
	state attr.ValueState
}

func (v RelationshipsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["user"] = basetypes.ObjectType{
		AttrTypes: UserValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RelationshipsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RelationshipsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RelationshipsValue) String() string {
	return "RelationshipsValue"
}

func (v RelationshipsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var user basetypes.ObjectValue

	if v.User.IsNull() {
		user = types.ObjectNull(
			UserValue{}.AttributeTypes(ctx),
		)
	}

	if v.User.IsUnknown() {
		user = types.ObjectUnknown(
			UserValue{}.AttributeTypes(ctx),
		)
	}

	if !v.User.IsNull() && !v.User.IsUnknown() {
		user = types.ObjectValueMust(
			UserValue{}.AttributeTypes(ctx),
			v.User.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"user": basetypes.ObjectType{
			AttrTypes: UserValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"user": user,
		})

	return objVal, diags
}

func (v RelationshipsValue) Equal(o attr.Value) bool {
	other, ok := o.(RelationshipsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.User.Equal(other.User) {
		return false
	}

	return true
}

func (v RelationshipsValue) Type(ctx context.Context) attr.Type {
	return RelationshipsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RelationshipsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"user": basetypes.ObjectType{
			AttrTypes: UserValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = UserType{}

type UserType struct {
	basetypes.ObjectType
}

func (t UserType) Equal(o attr.Type) bool {
	other, ok := o.(UserType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UserType) String() string {
	return "UserType"
}

func (t UserType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return nil, diags
	}

	dataVal, ok := dataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ObjectValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UserValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewUserValueNull() UserValue {
	return UserValue{
		state: attr.ValueStateNull,
	}
}

func NewUserValueUnknown() UserValue {
	return UserValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUserValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UserValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UserValue Attribute Value",
				"While creating a UserValue value, a missing attribute value was detected. "+
					"A UserValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UserValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UserValue Attribute Type",
				"While creating a UserValue value, an invalid attribute value was detected. "+
					"A UserValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UserValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UserValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UserValue Attribute Value",
				"While creating a UserValue value, an extra attribute value was detected. "+
					"A UserValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UserValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUserValueUnknown(), diags
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return NewUserValueUnknown(), diags
	}

	dataVal, ok := dataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ObjectValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return NewUserValueUnknown(), diags
	}

	return UserValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewUserValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UserValue {
	object, diags := NewUserValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUserValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UserType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUserValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUserValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUserValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUserValueMust(UserValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UserType) ValueType(ctx context.Context) attr.Value {
	return UserValue{}
}

var _ basetypes.ObjectValuable = UserValue{}

type UserValue struct {
	Data  basetypes.ObjectValue `tfsdk:"data"`
	state attr.ValueState
}

func (v UserValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["data"] = basetypes.ObjectType{
		AttrTypes: DataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Data.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UserValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UserValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UserValue) String() string {
	return "UserValue"
}

func (v UserValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var data basetypes.ObjectValue

	if v.Data.IsNull() {
		data = types.ObjectNull(
			DataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Data.IsUnknown() {
		data = types.ObjectUnknown(
			DataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Data.IsNull() && !v.Data.IsUnknown() {
		data = types.ObjectValueMust(
			DataValue{}.AttributeTypes(ctx),
			v.Data.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"data": basetypes.ObjectType{
			AttrTypes: DataValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data": data,
		})

	return objVal, diags
}

func (v UserValue) Equal(o attr.Value) bool {
	other, ok := o.(UserValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Data.Equal(other.Data) {
		return false
	}

	return true
}

func (v UserValue) Type(ctx context.Context) attr.Type {
	return UserType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UserValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data": basetypes.ObjectType{
			AttrTypes: DataValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Id       basetypes.StringValue `tfsdk:"id"`
	DataType basetypes.StringValue `tfsdk:"type"`
	state    attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":   v.Id,
			"type": v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}
