// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_domain_certificates

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DomainCertificatesResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"clone": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"certificate_id": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "The ID of the certificate to clone.",
						MarkdownDescription: "The ID of the certificate to clone.",
					},
				},
				CustomType: CloneType{
					ObjectType: types.ObjectType{
						AttrTypes: CloneValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"csr": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"city": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The city for the CSR.",
						MarkdownDescription: "The city for the CSR.",
					},
					"country": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The country for the CSR.",
						MarkdownDescription: "The country for the CSR.",
					},
					"department": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The department for the CSR.",
						MarkdownDescription: "The department for the CSR.",
					},
					"domain": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The domain to generate a CSR for.",
						MarkdownDescription: "The domain to generate a CSR for.",
					},
					"organization": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The organization for the CSR.",
						MarkdownDescription: "The organization for the CSR.",
					},
					"sans": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The SANs for the CSR, comma-separated.",
						MarkdownDescription: "The SANs for the CSR, comma-separated.",
					},
					"state": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The state for the CSR.",
						MarkdownDescription: "The state for the CSR.",
					},
				},
				CustomType: CsrType{
					ObjectType: types.ObjectType{
						AttrTypes: CsrValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "The configuration for a CSR (Certificate Signing Request).",
				MarkdownDescription: "The configuration for a CSR (Certificate Signing Request).",
			},
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"attributes": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"created_at": schema.StringAttribute{
								Computed:            true,
								Description:         "The date and time the certificate was created.",
								MarkdownDescription: "The date and time the certificate was created.",
							},
							"key_type": schema.StringAttribute{
								Computed: true,
							},
							"preferred_chain": schema.StringAttribute{
								Computed:            true,
								Description:         "The preferred chain for Let's Encrypt certificates.",
								MarkdownDescription: "The preferred chain for Let's Encrypt certificates.",
							},
							"request_status": schema.StringAttribute{
								Computed: true,
							},
							"status": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed: true,
							},
							"updated_at": schema.StringAttribute{
								Computed:            true,
								Description:         "The date and time the certificate was last updated.",
								MarkdownDescription: "The date and time the certificate was last updated.",
							},
							"verification_method": schema.StringAttribute{
								Computed: true,
							},
						},
						CustomType: AttributesType{
							ObjectType: types.ObjectType{
								AttrTypes: AttributesValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"links": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"self": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"describedby": schema.StringAttribute{
										Computed: true,
									},
									"href": schema.StringAttribute{
										Computed: true,
									},
									"hreflang": schema.StringAttribute{
										Computed:            true,
										Description:         "Language of the target link",
										MarkdownDescription: "Language of the target link",
									},
									"meta": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{},
										CustomType: MetaType{
											ObjectType: types.ObjectType{
												AttrTypes: MetaValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"rel": schema.StringAttribute{
										Computed: true,
									},
									"title": schema.StringAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: SelfType{
									ObjectType: types.ObjectType{
										AttrTypes: SelfValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
						},
						CustomType: LinksType{
							ObjectType: types.ObjectType{
								AttrTypes: LinksValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"type": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"domain_record": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The domain record ID",
				MarkdownDescription: "The domain record ID",
			},
			"existing": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"certificate": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The certificate chain for an existing certificate.",
						MarkdownDescription: "The certificate chain for an existing certificate.",
					},
					"key": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The private key for an existing certificate.",
						MarkdownDescription: "The private key for an existing certificate.",
					},
				},
				CustomType: ExistingType{
					ObjectType: types.ObjectType{
						AttrTypes: ExistingValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "The configuration for an existing certificate.",
				MarkdownDescription: "The configuration for an existing certificate.",
			},
			"letsencrypt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"key_type": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ecdsa",
								"rsa",
							),
						},
					},
					"preferred_chain": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The preferred chain for the Let's Encrypt certificate.",
						MarkdownDescription: "The preferred chain for the Let's Encrypt certificate.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ISRG Root X1",
							),
						},
					},
					"verification_method": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"http-01",
								"dns-01",
							),
						},
					},
				},
				CustomType: LetsencryptType{
					ObjectType: types.ObjectType{
						AttrTypes: LetsencryptValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "The configuration for a Let's Encrypt certificate.",
				MarkdownDescription: "The configuration for a Let's Encrypt certificate.",
			},
			"organization": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The organization slug",
				MarkdownDescription: "The organization slug",
			},
			"server": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The server ID",
				MarkdownDescription: "The server ID",
			},
			"site": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The site ID",
				MarkdownDescription: "The site ID",
			},
			"type": schema.StringAttribute{
				Required:            true,
				Description:         "The type of certificate to create.",
				MarkdownDescription: "The type of certificate to create.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"letsencrypt",
						"csr",
						"existing",
						"clone",
					),
				},
			},
		},
	}
}

type DomainCertificatesModel struct {
	Clone        CloneValue       `tfsdk:"clone"`
	Csr          CsrValue         `tfsdk:"csr"`
	Data         DataValue        `tfsdk:"data"`
	DomainRecord types.Int64      `tfsdk:"domain_record"`
	Existing     ExistingValue    `tfsdk:"existing"`
	Letsencrypt  LetsencryptValue `tfsdk:"letsencrypt"`
	Organization types.String     `tfsdk:"organization"`
	Server       types.Int64      `tfsdk:"server"`
	Site         types.Int64      `tfsdk:"site"`
	Type         types.String     `tfsdk:"type"`
}

var _ basetypes.ObjectTypable = CloneType{}

type CloneType struct {
	basetypes.ObjectType
}

func (t CloneType) Equal(o attr.Type) bool {
	other, ok := o.(CloneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CloneType) String() string {
	return "CloneType"
}

func (t CloneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certificateIdAttribute, ok := attributes["certificate_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate_id is missing from object`)

		return nil, diags
	}

	certificateIdVal, ok := certificateIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate_id expected to be basetypes.Int64Value, was: %T`, certificateIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CloneValue{
		CertificateId: certificateIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewCloneValueNull() CloneValue {
	return CloneValue{
		state: attr.ValueStateNull,
	}
}

func NewCloneValueUnknown() CloneValue {
	return CloneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCloneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CloneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CloneValue Attribute Value",
				"While creating a CloneValue value, a missing attribute value was detected. "+
					"A CloneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CloneValue Attribute Type",
				"While creating a CloneValue value, an invalid attribute value was detected. "+
					"A CloneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CloneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CloneValue Attribute Value",
				"While creating a CloneValue value, an extra attribute value was detected. "+
					"A CloneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CloneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCloneValueUnknown(), diags
	}

	certificateIdAttribute, ok := attributes["certificate_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate_id is missing from object`)

		return NewCloneValueUnknown(), diags
	}

	certificateIdVal, ok := certificateIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate_id expected to be basetypes.Int64Value, was: %T`, certificateIdAttribute))
	}

	if diags.HasError() {
		return NewCloneValueUnknown(), diags
	}

	return CloneValue{
		CertificateId: certificateIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewCloneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CloneValue {
	object, diags := NewCloneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCloneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CloneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCloneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCloneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCloneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCloneValueMust(CloneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CloneType) ValueType(ctx context.Context) attr.Value {
	return CloneValue{}
}

var _ basetypes.ObjectValuable = CloneValue{}

type CloneValue struct {
	CertificateId basetypes.Int64Value `tfsdk:"certificate_id"`
	state         attr.ValueState
}

func (v CloneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["certificate_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.CertificateId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["certificate_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CloneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CloneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CloneValue) String() string {
	return "CloneValue"
}

func (v CloneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"certificate_id": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"certificate_id": v.CertificateId,
		})

	return objVal, diags
}

func (v CloneValue) Equal(o attr.Value) bool {
	other, ok := o.(CloneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CertificateId.Equal(other.CertificateId) {
		return false
	}

	return true
}

func (v CloneValue) Type(ctx context.Context) attr.Type {
	return CloneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CloneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"certificate_id": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = CsrType{}

type CsrType struct {
	basetypes.ObjectType
}

func (t CsrType) Equal(o attr.Type) bool {
	other, ok := o.(CsrType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CsrType) String() string {
	return "CsrType"
}

func (t CsrType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return nil, diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return nil, diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	departmentAttribute, ok := attributes["department"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`department is missing from object`)

		return nil, diags
	}

	departmentVal, ok := departmentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`department expected to be basetypes.StringValue, was: %T`, departmentAttribute))
	}

	domainAttribute, ok := attributes["domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain is missing from object`)

		return nil, diags
	}

	domainVal, ok := domainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain expected to be basetypes.StringValue, was: %T`, domainAttribute))
	}

	organizationAttribute, ok := attributes["organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization is missing from object`)

		return nil, diags
	}

	organizationVal, ok := organizationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization expected to be basetypes.StringValue, was: %T`, organizationAttribute))
	}

	sansAttribute, ok := attributes["sans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sans is missing from object`)

		return nil, diags
	}

	sansVal, ok := sansAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sans expected to be basetypes.StringValue, was: %T`, sansAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CsrValue{
		City:         cityVal,
		Country:      countryVal,
		Department:   departmentVal,
		Domain:       domainVal,
		Organization: organizationVal,
		Sans:         sansVal,
		State:        stateVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewCsrValueNull() CsrValue {
	return CsrValue{
		state: attr.ValueStateNull,
	}
}

func NewCsrValueUnknown() CsrValue {
	return CsrValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCsrValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CsrValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CsrValue Attribute Value",
				"While creating a CsrValue value, a missing attribute value was detected. "+
					"A CsrValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CsrValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CsrValue Attribute Type",
				"While creating a CsrValue value, an invalid attribute value was detected. "+
					"A CsrValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CsrValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CsrValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CsrValue Attribute Value",
				"While creating a CsrValue value, an extra attribute value was detected. "+
					"A CsrValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CsrValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCsrValueUnknown(), diags
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return NewCsrValueUnknown(), diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return NewCsrValueUnknown(), diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	departmentAttribute, ok := attributes["department"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`department is missing from object`)

		return NewCsrValueUnknown(), diags
	}

	departmentVal, ok := departmentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`department expected to be basetypes.StringValue, was: %T`, departmentAttribute))
	}

	domainAttribute, ok := attributes["domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain is missing from object`)

		return NewCsrValueUnknown(), diags
	}

	domainVal, ok := domainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain expected to be basetypes.StringValue, was: %T`, domainAttribute))
	}

	organizationAttribute, ok := attributes["organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization is missing from object`)

		return NewCsrValueUnknown(), diags
	}

	organizationVal, ok := organizationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization expected to be basetypes.StringValue, was: %T`, organizationAttribute))
	}

	sansAttribute, ok := attributes["sans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sans is missing from object`)

		return NewCsrValueUnknown(), diags
	}

	sansVal, ok := sansAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sans expected to be basetypes.StringValue, was: %T`, sansAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewCsrValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return NewCsrValueUnknown(), diags
	}

	return CsrValue{
		City:         cityVal,
		Country:      countryVal,
		Department:   departmentVal,
		Domain:       domainVal,
		Organization: organizationVal,
		Sans:         sansVal,
		State:        stateVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewCsrValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CsrValue {
	object, diags := NewCsrValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCsrValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CsrType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCsrValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCsrValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCsrValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCsrValueMust(CsrValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CsrType) ValueType(ctx context.Context) attr.Value {
	return CsrValue{}
}

var _ basetypes.ObjectValuable = CsrValue{}

type CsrValue struct {
	City         basetypes.StringValue `tfsdk:"city"`
	Country      basetypes.StringValue `tfsdk:"country"`
	Department   basetypes.StringValue `tfsdk:"department"`
	Domain       basetypes.StringValue `tfsdk:"domain"`
	Organization basetypes.StringValue `tfsdk:"organization"`
	Sans         basetypes.StringValue `tfsdk:"sans"`
	State        basetypes.StringValue `tfsdk:"state"`
	state        attr.ValueState
}

func (v CsrValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["city"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["country"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["department"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["domain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["organization"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sans"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.City.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city"] = val

		val, err = v.Country.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country"] = val

		val, err = v.Department.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["department"] = val

		val, err = v.Domain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domain"] = val

		val, err = v.Organization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["organization"] = val

		val, err = v.Sans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sans"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CsrValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CsrValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CsrValue) String() string {
	return "CsrValue"
}

func (v CsrValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"city":         basetypes.StringType{},
		"country":      basetypes.StringType{},
		"department":   basetypes.StringType{},
		"domain":       basetypes.StringType{},
		"organization": basetypes.StringType{},
		"sans":         basetypes.StringType{},
		"state":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"city":         v.City,
			"country":      v.Country,
			"department":   v.Department,
			"domain":       v.Domain,
			"organization": v.Organization,
			"sans":         v.Sans,
			"state":        v.State,
		})

	return objVal, diags
}

func (v CsrValue) Equal(o attr.Value) bool {
	other, ok := o.(CsrValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.City.Equal(other.City) {
		return false
	}

	if !v.Country.Equal(other.Country) {
		return false
	}

	if !v.Department.Equal(other.Department) {
		return false
	}

	if !v.Domain.Equal(other.Domain) {
		return false
	}

	if !v.Organization.Equal(other.Organization) {
		return false
	}

	if !v.Sans.Equal(other.Sans) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	return true
}

func (v CsrValue) Type(ctx context.Context) attr.Type {
	return CsrType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CsrValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"city":         basetypes.StringType{},
		"country":      basetypes.StringType{},
		"department":   basetypes.StringType{},
		"domain":       basetypes.StringType{},
		"organization": basetypes.StringType{},
		"sans":         basetypes.StringType{},
		"state":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return nil, diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.ObjectValue, was: %T`, attributesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return nil, diags
	}

	linksVal, ok := linksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ObjectValue, was: %T`, linksAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Attributes: attributesVal,
		Id:         idVal,
		Links:      linksVal,
		DataType:   typeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return NewDataValueUnknown(), diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.ObjectValue, was: %T`, attributesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return NewDataValueUnknown(), diags
	}

	linksVal, ok := linksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ObjectValue, was: %T`, linksAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Attributes: attributesVal,
		Id:         idVal,
		Links:      linksVal,
		DataType:   typeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Attributes basetypes.ObjectValue `tfsdk:"attributes"`
	Id         basetypes.StringValue `tfsdk:"id"`
	Links      basetypes.ObjectValue `tfsdk:"links"`
	DataType   basetypes.StringValue `tfsdk:"type"`
	state      attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["attributes"] = basetypes.ObjectType{
		AttrTypes: AttributesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["links"] = basetypes.ObjectType{
		AttrTypes: LinksValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Attributes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attributes"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Links.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["links"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attributes basetypes.ObjectValue

	if v.Attributes.IsNull() {
		attributes = types.ObjectNull(
			AttributesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Attributes.IsUnknown() {
		attributes = types.ObjectUnknown(
			AttributesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Attributes.IsNull() && !v.Attributes.IsUnknown() {
		attributes = types.ObjectValueMust(
			AttributesValue{}.AttributeTypes(ctx),
			v.Attributes.Attributes(),
		)
	}

	var links basetypes.ObjectValue

	if v.Links.IsNull() {
		links = types.ObjectNull(
			LinksValue{}.AttributeTypes(ctx),
		)
	}

	if v.Links.IsUnknown() {
		links = types.ObjectUnknown(
			LinksValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Links.IsNull() && !v.Links.IsUnknown() {
		links = types.ObjectValueMust(
			LinksValue{}.AttributeTypes(ctx),
			v.Links.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"attributes": basetypes.ObjectType{
			AttrTypes: AttributesValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"links": basetypes.ObjectType{
			AttrTypes: LinksValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attributes": attributes,
			"id":         v.Id,
			"links":      links,
			"type":       v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Attributes.Equal(other.Attributes) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Links.Equal(other.Links) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attributes": basetypes.ObjectType{
			AttrTypes: AttributesValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"links": basetypes.ObjectType{
			AttrTypes: LinksValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttributesType{}

type AttributesType struct {
	basetypes.ObjectType
}

func (t AttributesType) Equal(o attr.Type) bool {
	other, ok := o.(AttributesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttributesType) String() string {
	return "AttributesType"
}

func (t AttributesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	keyTypeAttribute, ok := attributes["key_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_type is missing from object`)

		return nil, diags
	}

	keyTypeVal, ok := keyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_type expected to be basetypes.StringValue, was: %T`, keyTypeAttribute))
	}

	preferredChainAttribute, ok := attributes["preferred_chain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_chain is missing from object`)

		return nil, diags
	}

	preferredChainVal, ok := preferredChainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_chain expected to be basetypes.StringValue, was: %T`, preferredChainAttribute))
	}

	requestStatusAttribute, ok := attributes["request_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_status is missing from object`)

		return nil, diags
	}

	requestStatusVal, ok := requestStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_status expected to be basetypes.StringValue, was: %T`, requestStatusAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	verificationMethodAttribute, ok := attributes["verification_method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verification_method is missing from object`)

		return nil, diags
	}

	verificationMethodVal, ok := verificationMethodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verification_method expected to be basetypes.StringValue, was: %T`, verificationMethodAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttributesValue{
		CreatedAt:          createdAtVal,
		KeyType:            keyTypeVal,
		PreferredChain:     preferredChainVal,
		RequestStatus:      requestStatusVal,
		Status:             statusVal,
		AttributesType:     typeVal,
		UpdatedAt:          updatedAtVal,
		VerificationMethod: verificationMethodVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueNull() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateNull,
	}
}

func NewAttributesValueUnknown() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAttributesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttributesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttributesValue Attribute Value",
				"While creating a AttributesValue value, a missing attribute value was detected. "+
					"A AttributesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttributesValue Attribute Type",
				"While creating a AttributesValue value, an invalid attribute value was detected. "+
					"A AttributesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttributesValue Attribute Value",
				"While creating a AttributesValue value, an extra attribute value was detected. "+
					"A AttributesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttributesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	keyTypeAttribute, ok := attributes["key_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_type is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	keyTypeVal, ok := keyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_type expected to be basetypes.StringValue, was: %T`, keyTypeAttribute))
	}

	preferredChainAttribute, ok := attributes["preferred_chain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_chain is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	preferredChainVal, ok := preferredChainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_chain expected to be basetypes.StringValue, was: %T`, preferredChainAttribute))
	}

	requestStatusAttribute, ok := attributes["request_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`request_status is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	requestStatusVal, ok := requestStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`request_status expected to be basetypes.StringValue, was: %T`, requestStatusAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	verificationMethodAttribute, ok := attributes["verification_method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verification_method is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	verificationMethodVal, ok := verificationMethodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verification_method expected to be basetypes.StringValue, was: %T`, verificationMethodAttribute))
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	return AttributesValue{
		CreatedAt:          createdAtVal,
		KeyType:            keyTypeVal,
		PreferredChain:     preferredChainVal,
		RequestStatus:      requestStatusVal,
		Status:             statusVal,
		AttributesType:     typeVal,
		UpdatedAt:          updatedAtVal,
		VerificationMethod: verificationMethodVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttributesValue {
	object, diags := NewAttributesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttributesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttributesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttributesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttributesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttributesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttributesValueMust(AttributesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AttributesType) ValueType(ctx context.Context) attr.Value {
	return AttributesValue{}
}

var _ basetypes.ObjectValuable = AttributesValue{}

type AttributesValue struct {
	CreatedAt          basetypes.StringValue `tfsdk:"created_at"`
	KeyType            basetypes.StringValue `tfsdk:"key_type"`
	PreferredChain     basetypes.StringValue `tfsdk:"preferred_chain"`
	RequestStatus      basetypes.StringValue `tfsdk:"request_status"`
	Status             basetypes.StringValue `tfsdk:"status"`
	AttributesType     basetypes.StringValue `tfsdk:"type"`
	UpdatedAt          basetypes.StringValue `tfsdk:"updated_at"`
	VerificationMethod basetypes.StringValue `tfsdk:"verification_method"`
	state              attr.ValueState
}

func (v AttributesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["preferred_chain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["request_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["verification_method"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.KeyType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key_type"] = val

		val, err = v.PreferredChain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preferred_chain"] = val

		val, err = v.RequestStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["request_status"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.AttributesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		val, err = v.VerificationMethod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["verification_method"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttributesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttributesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttributesValue) String() string {
	return "AttributesValue"
}

func (v AttributesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created_at":          basetypes.StringType{},
		"key_type":            basetypes.StringType{},
		"preferred_chain":     basetypes.StringType{},
		"request_status":      basetypes.StringType{},
		"status":              basetypes.StringType{},
		"type":                basetypes.StringType{},
		"updated_at":          basetypes.StringType{},
		"verification_method": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at":          v.CreatedAt,
			"key_type":            v.KeyType,
			"preferred_chain":     v.PreferredChain,
			"request_status":      v.RequestStatus,
			"status":              v.Status,
			"type":                v.AttributesType,
			"updated_at":          v.UpdatedAt,
			"verification_method": v.VerificationMethod,
		})

	return objVal, diags
}

func (v AttributesValue) Equal(o attr.Value) bool {
	other, ok := o.(AttributesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.KeyType.Equal(other.KeyType) {
		return false
	}

	if !v.PreferredChain.Equal(other.PreferredChain) {
		return false
	}

	if !v.RequestStatus.Equal(other.RequestStatus) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.AttributesType.Equal(other.AttributesType) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	if !v.VerificationMethod.Equal(other.VerificationMethod) {
		return false
	}

	return true
}

func (v AttributesValue) Type(ctx context.Context) attr.Type {
	return AttributesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttributesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at":          basetypes.StringType{},
		"key_type":            basetypes.StringType{},
		"preferred_chain":     basetypes.StringType{},
		"request_status":      basetypes.StringType{},
		"status":              basetypes.StringType{},
		"type":                basetypes.StringType{},
		"updated_at":          basetypes.StringType{},
		"verification_method": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LinksType{}

type LinksType struct {
	basetypes.ObjectType
}

func (t LinksType) Equal(o attr.Type) bool {
	other, ok := o.(LinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinksType) String() string {
	return "LinksType"
}

func (t LinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return nil, diags
	}

	selfVal, ok := selfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.ObjectValue, was: %T`, selfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinksValue{
		Self:  selfVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLinksValueNull() LinksValue {
	return LinksValue{
		state: attr.ValueStateNull,
	}
}

func NewLinksValueUnknown() LinksValue {
	return LinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinksValue Attribute Value",
				"While creating a LinksValue value, a missing attribute value was detected. "+
					"A LinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinksValue Attribute Type",
				"While creating a LinksValue value, an invalid attribute value was detected. "+
					"A LinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinksValue Attribute Value",
				"While creating a LinksValue value, an extra attribute value was detected. "+
					"A LinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	selfVal, ok := selfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.ObjectValue, was: %T`, selfAttribute))
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	return LinksValue{
		Self:  selfVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinksValue {
	object, diags := NewLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinksValueMust(LinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinksType) ValueType(ctx context.Context) attr.Value {
	return LinksValue{}
}

var _ basetypes.ObjectValuable = LinksValue{}

type LinksValue struct {
	Self  basetypes.ObjectValue `tfsdk:"self"`
	state attr.ValueState
}

func (v LinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["self"] = basetypes.ObjectType{
		AttrTypes: SelfValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Self.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["self"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinksValue) String() string {
	return "LinksValue"
}

func (v LinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var self basetypes.ObjectValue

	if v.Self.IsNull() {
		self = types.ObjectNull(
			SelfValue{}.AttributeTypes(ctx),
		)
	}

	if v.Self.IsUnknown() {
		self = types.ObjectUnknown(
			SelfValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Self.IsNull() && !v.Self.IsUnknown() {
		self = types.ObjectValueMust(
			SelfValue{}.AttributeTypes(ctx),
			v.Self.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"self": basetypes.ObjectType{
			AttrTypes: SelfValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"self": self,
		})

	return objVal, diags
}

func (v LinksValue) Equal(o attr.Value) bool {
	other, ok := o.(LinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Self.Equal(other.Self) {
		return false
	}

	return true
}

func (v LinksValue) Type(ctx context.Context) attr.Type {
	return LinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"self": basetypes.ObjectType{
			AttrTypes: SelfValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SelfType{}

type SelfType struct {
	basetypes.ObjectType
}

func (t SelfType) Equal(o attr.Type) bool {
	other, ok := o.(SelfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SelfType) String() string {
	return "SelfType"
}

func (t SelfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	describedbyAttribute, ok := attributes["describedby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`describedby is missing from object`)

		return nil, diags
	}

	describedbyVal, ok := describedbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`describedby expected to be basetypes.StringValue, was: %T`, describedbyAttribute))
	}

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return nil, diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	hreflangAttribute, ok := attributes["hreflang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hreflang is missing from object`)

		return nil, diags
	}

	hreflangVal, ok := hreflangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hreflang expected to be basetypes.StringValue, was: %T`, hreflangAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return nil, diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return nil, diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return nil, diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SelfValue{
		Describedby: describedbyVal,
		Href:        hrefVal,
		Hreflang:    hreflangVal,
		Meta:        metaVal,
		Rel:         relVal,
		Title:       titleVal,
		SelfType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSelfValueNull() SelfValue {
	return SelfValue{
		state: attr.ValueStateNull,
	}
}

func NewSelfValueUnknown() SelfValue {
	return SelfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSelfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SelfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SelfValue Attribute Value",
				"While creating a SelfValue value, a missing attribute value was detected. "+
					"A SelfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SelfValue Attribute Type",
				"While creating a SelfValue value, an invalid attribute value was detected. "+
					"A SelfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SelfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SelfValue Attribute Value",
				"While creating a SelfValue value, an extra attribute value was detected. "+
					"A SelfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SelfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSelfValueUnknown(), diags
	}

	describedbyAttribute, ok := attributes["describedby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`describedby is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	describedbyVal, ok := describedbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`describedby expected to be basetypes.StringValue, was: %T`, describedbyAttribute))
	}

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	hreflangAttribute, ok := attributes["hreflang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hreflang is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	hreflangVal, ok := hreflangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hreflang expected to be basetypes.StringValue, was: %T`, hreflangAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSelfValueUnknown(), diags
	}

	return SelfValue{
		Describedby: describedbyVal,
		Href:        hrefVal,
		Hreflang:    hreflangVal,
		Meta:        metaVal,
		Rel:         relVal,
		Title:       titleVal,
		SelfType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSelfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SelfValue {
	object, diags := NewSelfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSelfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SelfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSelfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSelfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSelfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSelfValueMust(SelfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SelfType) ValueType(ctx context.Context) attr.Value {
	return SelfValue{}
}

var _ basetypes.ObjectValuable = SelfValue{}

type SelfValue struct {
	Describedby basetypes.StringValue `tfsdk:"describedby"`
	Href        basetypes.StringValue `tfsdk:"href"`
	Hreflang    basetypes.StringValue `tfsdk:"hreflang"`
	Meta        basetypes.ObjectValue `tfsdk:"meta"`
	Rel         basetypes.StringValue `tfsdk:"rel"`
	Title       basetypes.StringValue `tfsdk:"title"`
	SelfType    basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v SelfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["describedby"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["href"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hreflang"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["meta"] = basetypes.ObjectType{
		AttrTypes: MetaValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["rel"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["title"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Describedby.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["describedby"] = val

		val, err = v.Href.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["href"] = val

		val, err = v.Hreflang.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hreflang"] = val

		val, err = v.Meta.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["meta"] = val

		val, err = v.Rel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rel"] = val

		val, err = v.Title.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["title"] = val

		val, err = v.SelfType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SelfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SelfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SelfValue) String() string {
	return "SelfValue"
}

func (v SelfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var meta basetypes.ObjectValue

	if v.Meta.IsNull() {
		meta = types.ObjectNull(
			MetaValue{}.AttributeTypes(ctx),
		)
	}

	if v.Meta.IsUnknown() {
		meta = types.ObjectUnknown(
			MetaValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Meta.IsNull() && !v.Meta.IsUnknown() {
		meta = types.ObjectValueMust(
			MetaValue{}.AttributeTypes(ctx),
			v.Meta.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"describedby": basetypes.StringType{},
		"href":        basetypes.StringType{},
		"hreflang":    basetypes.StringType{},
		"meta": basetypes.ObjectType{
			AttrTypes: MetaValue{}.AttributeTypes(ctx),
		},
		"rel":   basetypes.StringType{},
		"title": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"describedby": v.Describedby,
			"href":        v.Href,
			"hreflang":    v.Hreflang,
			"meta":        meta,
			"rel":         v.Rel,
			"title":       v.Title,
			"type":        v.SelfType,
		})

	return objVal, diags
}

func (v SelfValue) Equal(o attr.Value) bool {
	other, ok := o.(SelfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Describedby.Equal(other.Describedby) {
		return false
	}

	if !v.Href.Equal(other.Href) {
		return false
	}

	if !v.Hreflang.Equal(other.Hreflang) {
		return false
	}

	if !v.Meta.Equal(other.Meta) {
		return false
	}

	if !v.Rel.Equal(other.Rel) {
		return false
	}

	if !v.Title.Equal(other.Title) {
		return false
	}

	if !v.SelfType.Equal(other.SelfType) {
		return false
	}

	return true
}

func (v SelfValue) Type(ctx context.Context) attr.Type {
	return SelfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SelfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"describedby": basetypes.StringType{},
		"href":        basetypes.StringType{},
		"hreflang":    basetypes.StringType{},
		"meta": basetypes.ObjectType{
			AttrTypes: MetaValue{}.AttributeTypes(ctx),
		},
		"rel":   basetypes.StringType{},
		"title": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MetaType{}

type MetaType struct {
	basetypes.ObjectType
}

func (t MetaType) Equal(o attr.Type) bool {
	other, ok := o.(MetaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetaType) String() string {
	return "MetaType"
}

func (t MetaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return MetaValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewMetaValueNull() MetaValue {
	return MetaValue{
		state: attr.ValueStateNull,
	}
}

func NewMetaValueUnknown() MetaValue {
	return MetaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetaValue Attribute Value",
				"While creating a MetaValue value, a missing attribute value was detected. "+
					"A MetaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetaValue Attribute Type",
				"While creating a MetaValue value, an invalid attribute value was detected. "+
					"A MetaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetaValue Attribute Value",
				"While creating a MetaValue value, an extra attribute value was detected. "+
					"A MetaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	return MetaValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewMetaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetaValue {
	object, diags := NewMetaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetaValueMust(MetaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetaType) ValueType(ctx context.Context) attr.Value {
	return MetaValue{}
}

var _ basetypes.ObjectValuable = MetaValue{}

type MetaValue struct {
	state attr.ValueState
}

func (v MetaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetaValue) String() string {
	return "MetaValue"
}

func (v MetaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v MetaValue) Equal(o attr.Value) bool {
	other, ok := o.(MetaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v MetaValue) Type(ctx context.Context) attr.Type {
	return MetaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = ExistingType{}

type ExistingType struct {
	basetypes.ObjectType
}

func (t ExistingType) Equal(o attr.Type) bool {
	other, ok := o.(ExistingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExistingType) String() string {
	return "ExistingType"
}

func (t ExistingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certificateAttribute, ok := attributes["certificate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate is missing from object`)

		return nil, diags
	}

	certificateVal, ok := certificateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate expected to be basetypes.StringValue, was: %T`, certificateAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExistingValue{
		Certificate: certificateVal,
		Key:         keyVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewExistingValueNull() ExistingValue {
	return ExistingValue{
		state: attr.ValueStateNull,
	}
}

func NewExistingValueUnknown() ExistingValue {
	return ExistingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExistingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExistingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExistingValue Attribute Value",
				"While creating a ExistingValue value, a missing attribute value was detected. "+
					"A ExistingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExistingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExistingValue Attribute Type",
				"While creating a ExistingValue value, an invalid attribute value was detected. "+
					"A ExistingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExistingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExistingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExistingValue Attribute Value",
				"While creating a ExistingValue value, an extra attribute value was detected. "+
					"A ExistingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExistingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExistingValueUnknown(), diags
	}

	certificateAttribute, ok := attributes["certificate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate is missing from object`)

		return NewExistingValueUnknown(), diags
	}

	certificateVal, ok := certificateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate expected to be basetypes.StringValue, was: %T`, certificateAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewExistingValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	if diags.HasError() {
		return NewExistingValueUnknown(), diags
	}

	return ExistingValue{
		Certificate: certificateVal,
		Key:         keyVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewExistingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExistingValue {
	object, diags := NewExistingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExistingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExistingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExistingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExistingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExistingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExistingValueMust(ExistingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExistingType) ValueType(ctx context.Context) attr.Value {
	return ExistingValue{}
}

var _ basetypes.ObjectValuable = ExistingValue{}

type ExistingValue struct {
	Certificate basetypes.StringValue `tfsdk:"certificate"`
	Key         basetypes.StringValue `tfsdk:"key"`
	state       attr.ValueState
}

func (v ExistingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["certificate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Certificate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["certificate"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExistingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExistingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExistingValue) String() string {
	return "ExistingValue"
}

func (v ExistingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"certificate": basetypes.StringType{},
		"key":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"certificate": v.Certificate,
			"key":         v.Key,
		})

	return objVal, diags
}

func (v ExistingValue) Equal(o attr.Value) bool {
	other, ok := o.(ExistingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Certificate.Equal(other.Certificate) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	return true
}

func (v ExistingValue) Type(ctx context.Context) attr.Type {
	return ExistingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExistingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"certificate": basetypes.StringType{},
		"key":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LetsencryptType{}

type LetsencryptType struct {
	basetypes.ObjectType
}

func (t LetsencryptType) Equal(o attr.Type) bool {
	other, ok := o.(LetsencryptType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LetsencryptType) String() string {
	return "LetsencryptType"
}

func (t LetsencryptType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	keyTypeAttribute, ok := attributes["key_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_type is missing from object`)

		return nil, diags
	}

	keyTypeVal, ok := keyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_type expected to be basetypes.StringValue, was: %T`, keyTypeAttribute))
	}

	preferredChainAttribute, ok := attributes["preferred_chain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_chain is missing from object`)

		return nil, diags
	}

	preferredChainVal, ok := preferredChainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_chain expected to be basetypes.StringValue, was: %T`, preferredChainAttribute))
	}

	verificationMethodAttribute, ok := attributes["verification_method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verification_method is missing from object`)

		return nil, diags
	}

	verificationMethodVal, ok := verificationMethodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verification_method expected to be basetypes.StringValue, was: %T`, verificationMethodAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LetsencryptValue{
		KeyType:            keyTypeVal,
		PreferredChain:     preferredChainVal,
		VerificationMethod: verificationMethodVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewLetsencryptValueNull() LetsencryptValue {
	return LetsencryptValue{
		state: attr.ValueStateNull,
	}
}

func NewLetsencryptValueUnknown() LetsencryptValue {
	return LetsencryptValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLetsencryptValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LetsencryptValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LetsencryptValue Attribute Value",
				"While creating a LetsencryptValue value, a missing attribute value was detected. "+
					"A LetsencryptValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LetsencryptValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LetsencryptValue Attribute Type",
				"While creating a LetsencryptValue value, an invalid attribute value was detected. "+
					"A LetsencryptValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LetsencryptValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LetsencryptValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LetsencryptValue Attribute Value",
				"While creating a LetsencryptValue value, an extra attribute value was detected. "+
					"A LetsencryptValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LetsencryptValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLetsencryptValueUnknown(), diags
	}

	keyTypeAttribute, ok := attributes["key_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_type is missing from object`)

		return NewLetsencryptValueUnknown(), diags
	}

	keyTypeVal, ok := keyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_type expected to be basetypes.StringValue, was: %T`, keyTypeAttribute))
	}

	preferredChainAttribute, ok := attributes["preferred_chain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_chain is missing from object`)

		return NewLetsencryptValueUnknown(), diags
	}

	preferredChainVal, ok := preferredChainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_chain expected to be basetypes.StringValue, was: %T`, preferredChainAttribute))
	}

	verificationMethodAttribute, ok := attributes["verification_method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verification_method is missing from object`)

		return NewLetsencryptValueUnknown(), diags
	}

	verificationMethodVal, ok := verificationMethodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verification_method expected to be basetypes.StringValue, was: %T`, verificationMethodAttribute))
	}

	if diags.HasError() {
		return NewLetsencryptValueUnknown(), diags
	}

	return LetsencryptValue{
		KeyType:            keyTypeVal,
		PreferredChain:     preferredChainVal,
		VerificationMethod: verificationMethodVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewLetsencryptValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LetsencryptValue {
	object, diags := NewLetsencryptValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLetsencryptValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LetsencryptType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLetsencryptValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLetsencryptValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLetsencryptValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLetsencryptValueMust(LetsencryptValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LetsencryptType) ValueType(ctx context.Context) attr.Value {
	return LetsencryptValue{}
}

var _ basetypes.ObjectValuable = LetsencryptValue{}

type LetsencryptValue struct {
	KeyType            basetypes.StringValue `tfsdk:"key_type"`
	PreferredChain     basetypes.StringValue `tfsdk:"preferred_chain"`
	VerificationMethod basetypes.StringValue `tfsdk:"verification_method"`
	state              attr.ValueState
}

func (v LetsencryptValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["key_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["preferred_chain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["verification_method"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.KeyType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key_type"] = val

		val, err = v.PreferredChain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preferred_chain"] = val

		val, err = v.VerificationMethod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["verification_method"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LetsencryptValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LetsencryptValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LetsencryptValue) String() string {
	return "LetsencryptValue"
}

func (v LetsencryptValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"key_type":            basetypes.StringType{},
		"preferred_chain":     basetypes.StringType{},
		"verification_method": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"key_type":            v.KeyType,
			"preferred_chain":     v.PreferredChain,
			"verification_method": v.VerificationMethod,
		})

	return objVal, diags
}

func (v LetsencryptValue) Equal(o attr.Value) bool {
	other, ok := o.(LetsencryptValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.KeyType.Equal(other.KeyType) {
		return false
	}

	if !v.PreferredChain.Equal(other.PreferredChain) {
		return false
	}

	if !v.VerificationMethod.Equal(other.VerificationMethod) {
		return false
	}

	return true
}

func (v LetsencryptValue) Type(ctx context.Context) attr.Type {
	return LetsencryptType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LetsencryptValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"key_type":            basetypes.StringType{},
		"preferred_chain":     basetypes.StringType{},
		"verification_method": basetypes.StringType{},
	}
}
