// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_servers

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ServersResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"add_key_to_source_control": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				Default:  booldefault.StaticBool(true),
			},
			"akamai": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"region_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"size_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: AkamaiType{
					ObjectType: types.ObjectType{
						AttrTypes: AkamaiValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"aws": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"disk_size": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"region_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"size_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"subnet_uuid": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"vpc_uuid": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: AwsType{
					ObjectType: types.ObjectType{
						AttrTypes: AwsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"credential_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"custom": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"behind_nat": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"ip_address": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"nat_ssh_port": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"private_ip_address": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"ssh_port": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: CustomType{
					ObjectType: types.ObjectType{
						AttrTypes: CustomValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"attributes": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"connection_status": schema.StringAttribute{
								Computed: true,
							},
							"created_at": schema.StringAttribute{
								Computed:            true,
								Description:         "The date and time the server was created.",
								MarkdownDescription: "The date and time the server was created.",
							},
							"credential_id": schema.Int64Attribute{
								Computed: true,
							},
							"database_type": schema.StringAttribute{
								Computed: true,
							},
							"db_status": schema.StringAttribute{
								Computed: true,
							},
							"id": schema.Int64Attribute{
								Computed: true,
							},
							"identifier": schema.StringAttribute{
								Computed: true,
							},
							"ip_address": schema.StringAttribute{
								Computed: true,
							},
							"is_ready": schema.BoolAttribute{
								Computed: true,
							},
							"local_public_key": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"opcache_status": schema.StringAttribute{
								Computed: true,
							},
							"php_cli_version": schema.StringAttribute{
								Computed: true,
							},
							"php_version": schema.StringAttribute{
								Computed: true,
							},
							"private_ip_address": schema.StringAttribute{
								Computed: true,
							},
							"provider": schema.StringAttribute{
								Computed: true,
							},
							"redis_status": schema.StringAttribute{
								Computed: true,
							},
							"region": schema.StringAttribute{
								Computed: true,
							},
							"revoked": schema.BoolAttribute{
								Computed: true,
							},
							"size": schema.StringAttribute{
								Computed: true,
							},
							"ssh_port": schema.Int64Attribute{
								Computed: true,
							},
							"timezone": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed: true,
							},
							"ubuntu_version": schema.StringAttribute{
								Computed: true,
							},
							"updated_at": schema.StringAttribute{
								Computed:            true,
								Description:         "The date and time the server was last updated.",
								MarkdownDescription: "The date and time the server was last updated.",
							},
						},
						CustomType: AttributesType{
							ObjectType: types.ObjectType{
								AttrTypes: AttributesValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"links": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"self": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"describedby": schema.StringAttribute{
										Computed: true,
									},
									"href": schema.StringAttribute{
										Computed: true,
									},
									"hreflang": schema.StringAttribute{
										Computed:            true,
										Description:         "Language of the target link",
										MarkdownDescription: "Language of the target link",
									},
									"meta": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{},
										CustomType: MetaType{
											ObjectType: types.ObjectType{
												AttrTypes: MetaValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"rel": schema.StringAttribute{
										Computed: true,
									},
									"title": schema.StringAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: SelfType{
									ObjectType: types.ObjectType{
										AttrTypes: SelfValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
						},
						CustomType: LinksType{
							ObjectType: types.ObjectType{
								AttrTypes: LinksValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"relationships": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"tags": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"data": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Computed: true,
												},
												"type": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: DataType{
												ObjectType: types.ObjectType{
													AttrTypes: DataValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
								},
								CustomType: TagsType{
									ObjectType: types.ObjectType{
										AttrTypes: TagsValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
						},
						CustomType: RelationshipsType{
							ObjectType: types.ObjectType{
								AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"type": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"database": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"database_type": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"hetzner": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enable_daily_backups": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"network_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"region_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"size_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: HetznerType{
					ObjectType: types.ObjectType{
						AttrTypes: HetznerValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"laravel": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"region_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"size_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"vpc_uuid": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: LaravelType{
					ObjectType: types.ObjectType{
						AttrTypes: LaravelValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(30),
				},
			},
			"ocean2": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enable_weekly_backups": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"region_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"size_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"vpc_uuid": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: Ocean2Type{
					ObjectType: types.ObjectType{
						AttrTypes: Ocean2Value{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"organization": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The organization slug",
				MarkdownDescription: "The organization slug",
			},
			"php_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"provider": schema.StringAttribute{
				Required: true,
			},
			"recipe_id": schema.Int64Attribute{
				Optional: true,
				Computed: true,
			},
			"server": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The server ID",
				MarkdownDescription: "The server ID",
			},
			"tags": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"team_id": schema.Int64Attribute{
				Optional: true,
				Computed: true,
			},
			"type": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"app",
						"web",
						"loadbalancer",
						"database",
						"cache",
						"worker",
						"meilisearch",
					),
				},
			},
			"ubuntu_version": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"22.04",
						"24.04",
					),
				},
			},
			"vultr": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"network_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"region_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"size_id": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: VultrType{
					ObjectType: types.ObjectType{
						AttrTypes: VultrValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
		},
	}
}

type ServersModel struct {
	AddKeyToSourceControl types.Bool   `tfsdk:"add_key_to_source_control"`
	Akamai                AkamaiValue  `tfsdk:"akamai"`
	Aws                   AwsValue     `tfsdk:"aws"`
	CredentialId          types.String `tfsdk:"credential_id"`
	Custom                CustomValue  `tfsdk:"custom"`
	Data                  DataValue    `tfsdk:"data"`
	Database              types.String `tfsdk:"database"`
	DatabaseType          types.String `tfsdk:"database_type"`
	Hetzner               HetznerValue `tfsdk:"hetzner"`
	Laravel               LaravelValue `tfsdk:"laravel"`
	Name                  types.String `tfsdk:"name"`
	Ocean2                Ocean2Value  `tfsdk:"ocean2"`
	Organization          types.String `tfsdk:"organization"`
	PhpVersion            types.String `tfsdk:"php_version"`
	Provider              types.String `tfsdk:"provider"`
	RecipeId              types.Int64  `tfsdk:"recipe_id"`
	Server                types.Int64  `tfsdk:"server"`
	Tags                  types.List   `tfsdk:"tags"`
	TeamId                types.Int64  `tfsdk:"team_id"`
	Type                  types.String `tfsdk:"type"`
	UbuntuVersion         types.String `tfsdk:"ubuntu_version"`
	Vultr                 VultrValue   `tfsdk:"vultr"`
}

var _ basetypes.ObjectTypable = AkamaiType{}

type AkamaiType struct {
	basetypes.ObjectType
}

func (t AkamaiType) Equal(o attr.Type) bool {
	other, ok := o.(AkamaiType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AkamaiType) String() string {
	return "AkamaiType"
}

func (t AkamaiType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return nil, diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return nil, diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AkamaiValue{
		RegionId: regionIdVal,
		SizeId:   sizeIdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAkamaiValueNull() AkamaiValue {
	return AkamaiValue{
		state: attr.ValueStateNull,
	}
}

func NewAkamaiValueUnknown() AkamaiValue {
	return AkamaiValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAkamaiValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AkamaiValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AkamaiValue Attribute Value",
				"While creating a AkamaiValue value, a missing attribute value was detected. "+
					"A AkamaiValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AkamaiValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AkamaiValue Attribute Type",
				"While creating a AkamaiValue value, an invalid attribute value was detected. "+
					"A AkamaiValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AkamaiValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AkamaiValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AkamaiValue Attribute Value",
				"While creating a AkamaiValue value, an extra attribute value was detected. "+
					"A AkamaiValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AkamaiValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAkamaiValueUnknown(), diags
	}

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return NewAkamaiValueUnknown(), diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return NewAkamaiValueUnknown(), diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	if diags.HasError() {
		return NewAkamaiValueUnknown(), diags
	}

	return AkamaiValue{
		RegionId: regionIdVal,
		SizeId:   sizeIdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAkamaiValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AkamaiValue {
	object, diags := NewAkamaiValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAkamaiValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AkamaiType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAkamaiValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAkamaiValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAkamaiValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAkamaiValueMust(AkamaiValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AkamaiType) ValueType(ctx context.Context) attr.Value {
	return AkamaiValue{}
}

var _ basetypes.ObjectValuable = AkamaiValue{}

type AkamaiValue struct {
	RegionId basetypes.StringValue `tfsdk:"region_id"`
	SizeId   basetypes.StringValue `tfsdk:"size_id"`
	state    attr.ValueState
}

func (v AkamaiValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["region_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.RegionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region_id"] = val

		val, err = v.SizeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AkamaiValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AkamaiValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AkamaiValue) String() string {
	return "AkamaiValue"
}

func (v AkamaiValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"region_id": basetypes.StringType{},
		"size_id":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"region_id": v.RegionId,
			"size_id":   v.SizeId,
		})

	return objVal, diags
}

func (v AkamaiValue) Equal(o attr.Value) bool {
	other, ok := o.(AkamaiValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.RegionId.Equal(other.RegionId) {
		return false
	}

	if !v.SizeId.Equal(other.SizeId) {
		return false
	}

	return true
}

func (v AkamaiValue) Type(ctx context.Context) attr.Type {
	return AkamaiType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AkamaiValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"region_id": basetypes.StringType{},
		"size_id":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AwsType{}

type AwsType struct {
	basetypes.ObjectType
}

func (t AwsType) Equal(o attr.Type) bool {
	other, ok := o.(AwsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AwsType) String() string {
	return "AwsType"
}

func (t AwsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	diskSizeAttribute, ok := attributes["disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_size is missing from object`)

		return nil, diags
	}

	diskSizeVal, ok := diskSizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_size expected to be basetypes.StringValue, was: %T`, diskSizeAttribute))
	}

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return nil, diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return nil, diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return nil, diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	vpcUuidAttribute, ok := attributes["vpc_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc_uuid is missing from object`)

		return nil, diags
	}

	vpcUuidVal, ok := vpcUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc_uuid expected to be basetypes.StringValue, was: %T`, vpcUuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AwsValue{
		DiskSize:   diskSizeVal,
		RegionId:   regionIdVal,
		SizeId:     sizeIdVal,
		SubnetUuid: subnetUuidVal,
		VpcUuid:    vpcUuidVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAwsValueNull() AwsValue {
	return AwsValue{
		state: attr.ValueStateNull,
	}
}

func NewAwsValueUnknown() AwsValue {
	return AwsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAwsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AwsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AwsValue Attribute Value",
				"While creating a AwsValue value, a missing attribute value was detected. "+
					"A AwsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AwsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AwsValue Attribute Type",
				"While creating a AwsValue value, an invalid attribute value was detected. "+
					"A AwsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AwsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AwsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AwsValue Attribute Value",
				"While creating a AwsValue value, an extra attribute value was detected. "+
					"A AwsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AwsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAwsValueUnknown(), diags
	}

	diskSizeAttribute, ok := attributes["disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_size is missing from object`)

		return NewAwsValueUnknown(), diags
	}

	diskSizeVal, ok := diskSizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_size expected to be basetypes.StringValue, was: %T`, diskSizeAttribute))
	}

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return NewAwsValueUnknown(), diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return NewAwsValueUnknown(), diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return NewAwsValueUnknown(), diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	vpcUuidAttribute, ok := attributes["vpc_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc_uuid is missing from object`)

		return NewAwsValueUnknown(), diags
	}

	vpcUuidVal, ok := vpcUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc_uuid expected to be basetypes.StringValue, was: %T`, vpcUuidAttribute))
	}

	if diags.HasError() {
		return NewAwsValueUnknown(), diags
	}

	return AwsValue{
		DiskSize:   diskSizeVal,
		RegionId:   regionIdVal,
		SizeId:     sizeIdVal,
		SubnetUuid: subnetUuidVal,
		VpcUuid:    vpcUuidVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAwsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AwsValue {
	object, diags := NewAwsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAwsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AwsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAwsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAwsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAwsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAwsValueMust(AwsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AwsType) ValueType(ctx context.Context) attr.Value {
	return AwsValue{}
}

var _ basetypes.ObjectValuable = AwsValue{}

type AwsValue struct {
	DiskSize   basetypes.StringValue `tfsdk:"disk_size"`
	RegionId   basetypes.StringValue `tfsdk:"region_id"`
	SizeId     basetypes.StringValue `tfsdk:"size_id"`
	SubnetUuid basetypes.StringValue `tfsdk:"subnet_uuid"`
	VpcUuid    basetypes.StringValue `tfsdk:"vpc_uuid"`
	state      attr.ValueState
}

func (v AwsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["disk_size"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vpc_uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DiskSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_size"] = val

		val, err = v.RegionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region_id"] = val

		val, err = v.SizeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_id"] = val

		val, err = v.SubnetUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_uuid"] = val

		val, err = v.VpcUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpc_uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AwsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AwsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AwsValue) String() string {
	return "AwsValue"
}

func (v AwsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"disk_size":   basetypes.StringType{},
		"region_id":   basetypes.StringType{},
		"size_id":     basetypes.StringType{},
		"subnet_uuid": basetypes.StringType{},
		"vpc_uuid":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disk_size":   v.DiskSize,
			"region_id":   v.RegionId,
			"size_id":     v.SizeId,
			"subnet_uuid": v.SubnetUuid,
			"vpc_uuid":    v.VpcUuid,
		})

	return objVal, diags
}

func (v AwsValue) Equal(o attr.Value) bool {
	other, ok := o.(AwsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DiskSize.Equal(other.DiskSize) {
		return false
	}

	if !v.RegionId.Equal(other.RegionId) {
		return false
	}

	if !v.SizeId.Equal(other.SizeId) {
		return false
	}

	if !v.SubnetUuid.Equal(other.SubnetUuid) {
		return false
	}

	if !v.VpcUuid.Equal(other.VpcUuid) {
		return false
	}

	return true
}

func (v AwsValue) Type(ctx context.Context) attr.Type {
	return AwsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AwsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disk_size":   basetypes.StringType{},
		"region_id":   basetypes.StringType{},
		"size_id":     basetypes.StringType{},
		"subnet_uuid": basetypes.StringType{},
		"vpc_uuid":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CustomType{}

type CustomType struct {
	basetypes.ObjectType
}

func (t CustomType) Equal(o attr.Type) bool {
	other, ok := o.(CustomType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomType) String() string {
	return "CustomType"
}

func (t CustomType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	behindNatAttribute, ok := attributes["behind_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`behind_nat is missing from object`)

		return nil, diags
	}

	behindNatVal, ok := behindNatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`behind_nat expected to be basetypes.StringValue, was: %T`, behindNatAttribute))
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	natSshPortAttribute, ok := attributes["nat_ssh_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_ssh_port is missing from object`)

		return nil, diags
	}

	natSshPortVal, ok := natSshPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_ssh_port expected to be basetypes.StringValue, was: %T`, natSshPortAttribute))
	}

	privateIpAddressAttribute, ok := attributes["private_ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip_address is missing from object`)

		return nil, diags
	}

	privateIpAddressVal, ok := privateIpAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip_address expected to be basetypes.StringValue, was: %T`, privateIpAddressAttribute))
	}

	sshPortAttribute, ok := attributes["ssh_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_port is missing from object`)

		return nil, diags
	}

	sshPortVal, ok := sshPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_port expected to be basetypes.StringValue, was: %T`, sshPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomValue{
		BehindNat:        behindNatVal,
		IpAddress:        ipAddressVal,
		NatSshPort:       natSshPortVal,
		PrivateIpAddress: privateIpAddressVal,
		SshPort:          sshPortVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCustomValueNull() CustomValue {
	return CustomValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomValueUnknown() CustomValue {
	return CustomValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomValue Attribute Value",
				"While creating a CustomValue value, a missing attribute value was detected. "+
					"A CustomValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomValue Attribute Type",
				"While creating a CustomValue value, an invalid attribute value was detected. "+
					"A CustomValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomValue Attribute Value",
				"While creating a CustomValue value, an extra attribute value was detected. "+
					"A CustomValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomValueUnknown(), diags
	}

	behindNatAttribute, ok := attributes["behind_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`behind_nat is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	behindNatVal, ok := behindNatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`behind_nat expected to be basetypes.StringValue, was: %T`, behindNatAttribute))
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	natSshPortAttribute, ok := attributes["nat_ssh_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_ssh_port is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	natSshPortVal, ok := natSshPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_ssh_port expected to be basetypes.StringValue, was: %T`, natSshPortAttribute))
	}

	privateIpAddressAttribute, ok := attributes["private_ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip_address is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	privateIpAddressVal, ok := privateIpAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip_address expected to be basetypes.StringValue, was: %T`, privateIpAddressAttribute))
	}

	sshPortAttribute, ok := attributes["ssh_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_port is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	sshPortVal, ok := sshPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_port expected to be basetypes.StringValue, was: %T`, sshPortAttribute))
	}

	if diags.HasError() {
		return NewCustomValueUnknown(), diags
	}

	return CustomValue{
		BehindNat:        behindNatVal,
		IpAddress:        ipAddressVal,
		NatSshPort:       natSshPortVal,
		PrivateIpAddress: privateIpAddressVal,
		SshPort:          sshPortVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCustomValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomValue {
	object, diags := NewCustomValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomValueMust(CustomValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomType) ValueType(ctx context.Context) attr.Value {
	return CustomValue{}
}

var _ basetypes.ObjectValuable = CustomValue{}

type CustomValue struct {
	BehindNat        basetypes.StringValue `tfsdk:"behind_nat"`
	IpAddress        basetypes.StringValue `tfsdk:"ip_address"`
	NatSshPort       basetypes.StringValue `tfsdk:"nat_ssh_port"`
	PrivateIpAddress basetypes.StringValue `tfsdk:"private_ip_address"`
	SshPort          basetypes.StringValue `tfsdk:"ssh_port"`
	state            attr.ValueState
}

func (v CustomValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["behind_nat"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nat_ssh_port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ssh_port"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BehindNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["behind_nat"] = val

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.NatSshPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_ssh_port"] = val

		val, err = v.PrivateIpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_ip_address"] = val

		val, err = v.SshPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssh_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomValue) String() string {
	return "CustomValue"
}

func (v CustomValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"behind_nat":         basetypes.StringType{},
		"ip_address":         basetypes.StringType{},
		"nat_ssh_port":       basetypes.StringType{},
		"private_ip_address": basetypes.StringType{},
		"ssh_port":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"behind_nat":         v.BehindNat,
			"ip_address":         v.IpAddress,
			"nat_ssh_port":       v.NatSshPort,
			"private_ip_address": v.PrivateIpAddress,
			"ssh_port":           v.SshPort,
		})

	return objVal, diags
}

func (v CustomValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BehindNat.Equal(other.BehindNat) {
		return false
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.NatSshPort.Equal(other.NatSshPort) {
		return false
	}

	if !v.PrivateIpAddress.Equal(other.PrivateIpAddress) {
		return false
	}

	if !v.SshPort.Equal(other.SshPort) {
		return false
	}

	return true
}

func (v CustomValue) Type(ctx context.Context) attr.Type {
	return CustomType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"behind_nat":         basetypes.StringType{},
		"ip_address":         basetypes.StringType{},
		"nat_ssh_port":       basetypes.StringType{},
		"private_ip_address": basetypes.StringType{},
		"ssh_port":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return nil, diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.ObjectValue, was: %T`, attributesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return nil, diags
	}

	linksVal, ok := linksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ObjectValue, was: %T`, linksAttribute))
	}

	relationshipsAttribute, ok := attributes["relationships"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`relationships is missing from object`)

		return nil, diags
	}

	relationshipsVal, ok := relationshipsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`relationships expected to be basetypes.ObjectValue, was: %T`, relationshipsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Attributes:    attributesVal,
		Id:            idVal,
		Links:         linksVal,
		Relationships: relationshipsVal,
		DataType:      typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return NewDataValueUnknown(), diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.ObjectValue, was: %T`, attributesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return NewDataValueUnknown(), diags
	}

	linksVal, ok := linksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ObjectValue, was: %T`, linksAttribute))
	}

	relationshipsAttribute, ok := attributes["relationships"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`relationships is missing from object`)

		return NewDataValueUnknown(), diags
	}

	relationshipsVal, ok := relationshipsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`relationships expected to be basetypes.ObjectValue, was: %T`, relationshipsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Attributes:    attributesVal,
		Id:            idVal,
		Links:         linksVal,
		Relationships: relationshipsVal,
		DataType:      typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Attributes    basetypes.ObjectValue `tfsdk:"attributes"`
	Id            basetypes.StringValue `tfsdk:"id"`
	Links         basetypes.ObjectValue `tfsdk:"links"`
	Relationships basetypes.ObjectValue `tfsdk:"relationships"`
	DataType      basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["attributes"] = basetypes.ObjectType{
		AttrTypes: AttributesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["links"] = basetypes.ObjectType{
		AttrTypes: LinksValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["relationships"] = basetypes.ObjectType{
		AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Attributes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attributes"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Links.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["links"] = val

		val, err = v.Relationships.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["relationships"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attributes basetypes.ObjectValue

	if v.Attributes.IsNull() {
		attributes = types.ObjectNull(
			AttributesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Attributes.IsUnknown() {
		attributes = types.ObjectUnknown(
			AttributesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Attributes.IsNull() && !v.Attributes.IsUnknown() {
		attributes = types.ObjectValueMust(
			AttributesValue{}.AttributeTypes(ctx),
			v.Attributes.Attributes(),
		)
	}

	var links basetypes.ObjectValue

	if v.Links.IsNull() {
		links = types.ObjectNull(
			LinksValue{}.AttributeTypes(ctx),
		)
	}

	if v.Links.IsUnknown() {
		links = types.ObjectUnknown(
			LinksValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Links.IsNull() && !v.Links.IsUnknown() {
		links = types.ObjectValueMust(
			LinksValue{}.AttributeTypes(ctx),
			v.Links.Attributes(),
		)
	}

	var relationships basetypes.ObjectValue

	if v.Relationships.IsNull() {
		relationships = types.ObjectNull(
			RelationshipsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Relationships.IsUnknown() {
		relationships = types.ObjectUnknown(
			RelationshipsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Relationships.IsNull() && !v.Relationships.IsUnknown() {
		relationships = types.ObjectValueMust(
			RelationshipsValue{}.AttributeTypes(ctx),
			v.Relationships.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"attributes": basetypes.ObjectType{
			AttrTypes: AttributesValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"links": basetypes.ObjectType{
			AttrTypes: LinksValue{}.AttributeTypes(ctx),
		},
		"relationships": basetypes.ObjectType{
			AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attributes":    attributes,
			"id":            v.Id,
			"links":         links,
			"relationships": relationships,
			"type":          v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Attributes.Equal(other.Attributes) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Links.Equal(other.Links) {
		return false
	}

	if !v.Relationships.Equal(other.Relationships) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attributes": basetypes.ObjectType{
			AttrTypes: AttributesValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"links": basetypes.ObjectType{
			AttrTypes: LinksValue{}.AttributeTypes(ctx),
		},
		"relationships": basetypes.ObjectType{
			AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttributesType{}

type AttributesType struct {
	basetypes.ObjectType
}

func (t AttributesType) Equal(o attr.Type) bool {
	other, ok := o.(AttributesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttributesType) String() string {
	return "AttributesType"
}

func (t AttributesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectionStatusAttribute, ok := attributes["connection_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_status is missing from object`)

		return nil, diags
	}

	connectionStatusVal, ok := connectionStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_status expected to be basetypes.StringValue, was: %T`, connectionStatusAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	credentialIdAttribute, ok := attributes["credential_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credential_id is missing from object`)

		return nil, diags
	}

	credentialIdVal, ok := credentialIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credential_id expected to be basetypes.Int64Value, was: %T`, credentialIdAttribute))
	}

	databaseTypeAttribute, ok := attributes["database_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database_type is missing from object`)

		return nil, diags
	}

	databaseTypeVal, ok := databaseTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database_type expected to be basetypes.StringValue, was: %T`, databaseTypeAttribute))
	}

	dbStatusAttribute, ok := attributes["db_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`db_status is missing from object`)

		return nil, diags
	}

	dbStatusVal, ok := dbStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`db_status expected to be basetypes.StringValue, was: %T`, dbStatusAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	identifierAttribute, ok := attributes["identifier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identifier is missing from object`)

		return nil, diags
	}

	identifierVal, ok := identifierAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identifier expected to be basetypes.StringValue, was: %T`, identifierAttribute))
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	isReadyAttribute, ok := attributes["is_ready"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_ready is missing from object`)

		return nil, diags
	}

	isReadyVal, ok := isReadyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_ready expected to be basetypes.BoolValue, was: %T`, isReadyAttribute))
	}

	localPublicKeyAttribute, ok := attributes["local_public_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_public_key is missing from object`)

		return nil, diags
	}

	localPublicKeyVal, ok := localPublicKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_public_key expected to be basetypes.StringValue, was: %T`, localPublicKeyAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	opcacheStatusAttribute, ok := attributes["opcache_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`opcache_status is missing from object`)

		return nil, diags
	}

	opcacheStatusVal, ok := opcacheStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`opcache_status expected to be basetypes.StringValue, was: %T`, opcacheStatusAttribute))
	}

	phpCliVersionAttribute, ok := attributes["php_cli_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`php_cli_version is missing from object`)

		return nil, diags
	}

	phpCliVersionVal, ok := phpCliVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`php_cli_version expected to be basetypes.StringValue, was: %T`, phpCliVersionAttribute))
	}

	phpVersionAttribute, ok := attributes["php_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`php_version is missing from object`)

		return nil, diags
	}

	phpVersionVal, ok := phpVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`php_version expected to be basetypes.StringValue, was: %T`, phpVersionAttribute))
	}

	privateIpAddressAttribute, ok := attributes["private_ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip_address is missing from object`)

		return nil, diags
	}

	privateIpAddressVal, ok := privateIpAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip_address expected to be basetypes.StringValue, was: %T`, privateIpAddressAttribute))
	}

	providerAttribute, ok := attributes["provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider is missing from object`)

		return nil, diags
	}

	providerVal, ok := providerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider expected to be basetypes.StringValue, was: %T`, providerAttribute))
	}

	redisStatusAttribute, ok := attributes["redis_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redis_status is missing from object`)

		return nil, diags
	}

	redisStatusVal, ok := redisStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redis_status expected to be basetypes.StringValue, was: %T`, redisStatusAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	revokedAttribute, ok := attributes["revoked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`revoked is missing from object`)

		return nil, diags
	}

	revokedVal, ok := revokedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`revoked expected to be basetypes.BoolValue, was: %T`, revokedAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.StringValue, was: %T`, sizeAttribute))
	}

	sshPortAttribute, ok := attributes["ssh_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_port is missing from object`)

		return nil, diags
	}

	sshPortVal, ok := sshPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_port expected to be basetypes.Int64Value, was: %T`, sshPortAttribute))
	}

	timezoneAttribute, ok := attributes["timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timezone is missing from object`)

		return nil, diags
	}

	timezoneVal, ok := timezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timezone expected to be basetypes.StringValue, was: %T`, timezoneAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	ubuntuVersionAttribute, ok := attributes["ubuntu_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ubuntu_version is missing from object`)

		return nil, diags
	}

	ubuntuVersionVal, ok := ubuntuVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ubuntu_version expected to be basetypes.StringValue, was: %T`, ubuntuVersionAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttributesValue{
		ConnectionStatus: connectionStatusVal,
		CreatedAt:        createdAtVal,
		CredentialId:     credentialIdVal,
		DatabaseType:     databaseTypeVal,
		DbStatus:         dbStatusVal,
		Id:               idVal,
		Identifier:       identifierVal,
		IpAddress:        ipAddressVal,
		IsReady:          isReadyVal,
		LocalPublicKey:   localPublicKeyVal,
		Name:             nameVal,
		OpcacheStatus:    opcacheStatusVal,
		PhpCliVersion:    phpCliVersionVal,
		PhpVersion:       phpVersionVal,
		PrivateIpAddress: privateIpAddressVal,
		Provider:         providerVal,
		RedisStatus:      redisStatusVal,
		Region:           regionVal,
		Revoked:          revokedVal,
		Size:             sizeVal,
		SshPort:          sshPortVal,
		Timezone:         timezoneVal,
		AttributesType:   typeVal,
		UbuntuVersion:    ubuntuVersionVal,
		UpdatedAt:        updatedAtVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueNull() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateNull,
	}
}

func NewAttributesValueUnknown() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAttributesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttributesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttributesValue Attribute Value",
				"While creating a AttributesValue value, a missing attribute value was detected. "+
					"A AttributesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttributesValue Attribute Type",
				"While creating a AttributesValue value, an invalid attribute value was detected. "+
					"A AttributesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttributesValue Attribute Value",
				"While creating a AttributesValue value, an extra attribute value was detected. "+
					"A AttributesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttributesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	connectionStatusAttribute, ok := attributes["connection_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_status is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	connectionStatusVal, ok := connectionStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_status expected to be basetypes.StringValue, was: %T`, connectionStatusAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	credentialIdAttribute, ok := attributes["credential_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credential_id is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	credentialIdVal, ok := credentialIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credential_id expected to be basetypes.Int64Value, was: %T`, credentialIdAttribute))
	}

	databaseTypeAttribute, ok := attributes["database_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database_type is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	databaseTypeVal, ok := databaseTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database_type expected to be basetypes.StringValue, was: %T`, databaseTypeAttribute))
	}

	dbStatusAttribute, ok := attributes["db_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`db_status is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	dbStatusVal, ok := dbStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`db_status expected to be basetypes.StringValue, was: %T`, dbStatusAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	identifierAttribute, ok := attributes["identifier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identifier is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	identifierVal, ok := identifierAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identifier expected to be basetypes.StringValue, was: %T`, identifierAttribute))
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	isReadyAttribute, ok := attributes["is_ready"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_ready is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	isReadyVal, ok := isReadyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_ready expected to be basetypes.BoolValue, was: %T`, isReadyAttribute))
	}

	localPublicKeyAttribute, ok := attributes["local_public_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_public_key is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	localPublicKeyVal, ok := localPublicKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_public_key expected to be basetypes.StringValue, was: %T`, localPublicKeyAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	opcacheStatusAttribute, ok := attributes["opcache_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`opcache_status is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	opcacheStatusVal, ok := opcacheStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`opcache_status expected to be basetypes.StringValue, was: %T`, opcacheStatusAttribute))
	}

	phpCliVersionAttribute, ok := attributes["php_cli_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`php_cli_version is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	phpCliVersionVal, ok := phpCliVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`php_cli_version expected to be basetypes.StringValue, was: %T`, phpCliVersionAttribute))
	}

	phpVersionAttribute, ok := attributes["php_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`php_version is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	phpVersionVal, ok := phpVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`php_version expected to be basetypes.StringValue, was: %T`, phpVersionAttribute))
	}

	privateIpAddressAttribute, ok := attributes["private_ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip_address is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	privateIpAddressVal, ok := privateIpAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip_address expected to be basetypes.StringValue, was: %T`, privateIpAddressAttribute))
	}

	providerAttribute, ok := attributes["provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	providerVal, ok := providerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider expected to be basetypes.StringValue, was: %T`, providerAttribute))
	}

	redisStatusAttribute, ok := attributes["redis_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redis_status is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	redisStatusVal, ok := redisStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redis_status expected to be basetypes.StringValue, was: %T`, redisStatusAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	revokedAttribute, ok := attributes["revoked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`revoked is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	revokedVal, ok := revokedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`revoked expected to be basetypes.BoolValue, was: %T`, revokedAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.StringValue, was: %T`, sizeAttribute))
	}

	sshPortAttribute, ok := attributes["ssh_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh_port is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	sshPortVal, ok := sshPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh_port expected to be basetypes.Int64Value, was: %T`, sshPortAttribute))
	}

	timezoneAttribute, ok := attributes["timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timezone is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	timezoneVal, ok := timezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timezone expected to be basetypes.StringValue, was: %T`, timezoneAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	ubuntuVersionAttribute, ok := attributes["ubuntu_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ubuntu_version is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	ubuntuVersionVal, ok := ubuntuVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ubuntu_version expected to be basetypes.StringValue, was: %T`, ubuntuVersionAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	return AttributesValue{
		ConnectionStatus: connectionStatusVal,
		CreatedAt:        createdAtVal,
		CredentialId:     credentialIdVal,
		DatabaseType:     databaseTypeVal,
		DbStatus:         dbStatusVal,
		Id:               idVal,
		Identifier:       identifierVal,
		IpAddress:        ipAddressVal,
		IsReady:          isReadyVal,
		LocalPublicKey:   localPublicKeyVal,
		Name:             nameVal,
		OpcacheStatus:    opcacheStatusVal,
		PhpCliVersion:    phpCliVersionVal,
		PhpVersion:       phpVersionVal,
		PrivateIpAddress: privateIpAddressVal,
		Provider:         providerVal,
		RedisStatus:      redisStatusVal,
		Region:           regionVal,
		Revoked:          revokedVal,
		Size:             sizeVal,
		SshPort:          sshPortVal,
		Timezone:         timezoneVal,
		AttributesType:   typeVal,
		UbuntuVersion:    ubuntuVersionVal,
		UpdatedAt:        updatedAtVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttributesValue {
	object, diags := NewAttributesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttributesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttributesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttributesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttributesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttributesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttributesValueMust(AttributesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AttributesType) ValueType(ctx context.Context) attr.Value {
	return AttributesValue{}
}

var _ basetypes.ObjectValuable = AttributesValue{}

type AttributesValue struct {
	ConnectionStatus basetypes.StringValue `tfsdk:"connection_status"`
	CreatedAt        basetypes.StringValue `tfsdk:"created_at"`
	CredentialId     basetypes.Int64Value  `tfsdk:"credential_id"`
	DatabaseType     basetypes.StringValue `tfsdk:"database_type"`
	DbStatus         basetypes.StringValue `tfsdk:"db_status"`
	Id               basetypes.Int64Value  `tfsdk:"id"`
	Identifier       basetypes.StringValue `tfsdk:"identifier"`
	IpAddress        basetypes.StringValue `tfsdk:"ip_address"`
	IsReady          basetypes.BoolValue   `tfsdk:"is_ready"`
	LocalPublicKey   basetypes.StringValue `tfsdk:"local_public_key"`
	Name             basetypes.StringValue `tfsdk:"name"`
	OpcacheStatus    basetypes.StringValue `tfsdk:"opcache_status"`
	PhpCliVersion    basetypes.StringValue `tfsdk:"php_cli_version"`
	PhpVersion       basetypes.StringValue `tfsdk:"php_version"`
	PrivateIpAddress basetypes.StringValue `tfsdk:"private_ip_address"`
	Provider         basetypes.StringValue `tfsdk:"provider"`
	RedisStatus      basetypes.StringValue `tfsdk:"redis_status"`
	Region           basetypes.StringValue `tfsdk:"region"`
	Revoked          basetypes.BoolValue   `tfsdk:"revoked"`
	Size             basetypes.StringValue `tfsdk:"size"`
	SshPort          basetypes.Int64Value  `tfsdk:"ssh_port"`
	Timezone         basetypes.StringValue `tfsdk:"timezone"`
	AttributesType   basetypes.StringValue `tfsdk:"type"`
	UbuntuVersion    basetypes.StringValue `tfsdk:"ubuntu_version"`
	UpdatedAt        basetypes.StringValue `tfsdk:"updated_at"`
	state            attr.ValueState
}

func (v AttributesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 25)

	var val tftypes.Value
	var err error

	attrTypes["connection_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["credential_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["database_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["db_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["identifier"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_ready"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["local_public_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["opcache_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["php_cli_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["php_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["redis_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["revoked"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ssh_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["timezone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ubuntu_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 25)

		val, err = v.ConnectionStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connection_status"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.CredentialId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["credential_id"] = val

		val, err = v.DatabaseType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database_type"] = val

		val, err = v.DbStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["db_status"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Identifier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["identifier"] = val

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.IsReady.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_ready"] = val

		val, err = v.LocalPublicKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_public_key"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OpcacheStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["opcache_status"] = val

		val, err = v.PhpCliVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["php_cli_version"] = val

		val, err = v.PhpVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["php_version"] = val

		val, err = v.PrivateIpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_ip_address"] = val

		val, err = v.Provider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider"] = val

		val, err = v.RedisStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redis_status"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Revoked.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["revoked"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		val, err = v.SshPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssh_port"] = val

		val, err = v.Timezone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timezone"] = val

		val, err = v.AttributesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UbuntuVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ubuntu_version"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttributesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttributesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttributesValue) String() string {
	return "AttributesValue"
}

func (v AttributesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"connection_status":  basetypes.StringType{},
		"created_at":         basetypes.StringType{},
		"credential_id":      basetypes.Int64Type{},
		"database_type":      basetypes.StringType{},
		"db_status":          basetypes.StringType{},
		"id":                 basetypes.Int64Type{},
		"identifier":         basetypes.StringType{},
		"ip_address":         basetypes.StringType{},
		"is_ready":           basetypes.BoolType{},
		"local_public_key":   basetypes.StringType{},
		"name":               basetypes.StringType{},
		"opcache_status":     basetypes.StringType{},
		"php_cli_version":    basetypes.StringType{},
		"php_version":        basetypes.StringType{},
		"private_ip_address": basetypes.StringType{},
		"provider":           basetypes.StringType{},
		"redis_status":       basetypes.StringType{},
		"region":             basetypes.StringType{},
		"revoked":            basetypes.BoolType{},
		"size":               basetypes.StringType{},
		"ssh_port":           basetypes.Int64Type{},
		"timezone":           basetypes.StringType{},
		"type":               basetypes.StringType{},
		"ubuntu_version":     basetypes.StringType{},
		"updated_at":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connection_status":  v.ConnectionStatus,
			"created_at":         v.CreatedAt,
			"credential_id":      v.CredentialId,
			"database_type":      v.DatabaseType,
			"db_status":          v.DbStatus,
			"id":                 v.Id,
			"identifier":         v.Identifier,
			"ip_address":         v.IpAddress,
			"is_ready":           v.IsReady,
			"local_public_key":   v.LocalPublicKey,
			"name":               v.Name,
			"opcache_status":     v.OpcacheStatus,
			"php_cli_version":    v.PhpCliVersion,
			"php_version":        v.PhpVersion,
			"private_ip_address": v.PrivateIpAddress,
			"provider":           v.Provider,
			"redis_status":       v.RedisStatus,
			"region":             v.Region,
			"revoked":            v.Revoked,
			"size":               v.Size,
			"ssh_port":           v.SshPort,
			"timezone":           v.Timezone,
			"type":               v.AttributesType,
			"ubuntu_version":     v.UbuntuVersion,
			"updated_at":         v.UpdatedAt,
		})

	return objVal, diags
}

func (v AttributesValue) Equal(o attr.Value) bool {
	other, ok := o.(AttributesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConnectionStatus.Equal(other.ConnectionStatus) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.CredentialId.Equal(other.CredentialId) {
		return false
	}

	if !v.DatabaseType.Equal(other.DatabaseType) {
		return false
	}

	if !v.DbStatus.Equal(other.DbStatus) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Identifier.Equal(other.Identifier) {
		return false
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.IsReady.Equal(other.IsReady) {
		return false
	}

	if !v.LocalPublicKey.Equal(other.LocalPublicKey) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OpcacheStatus.Equal(other.OpcacheStatus) {
		return false
	}

	if !v.PhpCliVersion.Equal(other.PhpCliVersion) {
		return false
	}

	if !v.PhpVersion.Equal(other.PhpVersion) {
		return false
	}

	if !v.PrivateIpAddress.Equal(other.PrivateIpAddress) {
		return false
	}

	if !v.Provider.Equal(other.Provider) {
		return false
	}

	if !v.RedisStatus.Equal(other.RedisStatus) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Revoked.Equal(other.Revoked) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	if !v.SshPort.Equal(other.SshPort) {
		return false
	}

	if !v.Timezone.Equal(other.Timezone) {
		return false
	}

	if !v.AttributesType.Equal(other.AttributesType) {
		return false
	}

	if !v.UbuntuVersion.Equal(other.UbuntuVersion) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v AttributesValue) Type(ctx context.Context) attr.Type {
	return AttributesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttributesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connection_status":  basetypes.StringType{},
		"created_at":         basetypes.StringType{},
		"credential_id":      basetypes.Int64Type{},
		"database_type":      basetypes.StringType{},
		"db_status":          basetypes.StringType{},
		"id":                 basetypes.Int64Type{},
		"identifier":         basetypes.StringType{},
		"ip_address":         basetypes.StringType{},
		"is_ready":           basetypes.BoolType{},
		"local_public_key":   basetypes.StringType{},
		"name":               basetypes.StringType{},
		"opcache_status":     basetypes.StringType{},
		"php_cli_version":    basetypes.StringType{},
		"php_version":        basetypes.StringType{},
		"private_ip_address": basetypes.StringType{},
		"provider":           basetypes.StringType{},
		"redis_status":       basetypes.StringType{},
		"region":             basetypes.StringType{},
		"revoked":            basetypes.BoolType{},
		"size":               basetypes.StringType{},
		"ssh_port":           basetypes.Int64Type{},
		"timezone":           basetypes.StringType{},
		"type":               basetypes.StringType{},
		"ubuntu_version":     basetypes.StringType{},
		"updated_at":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LinksType{}

type LinksType struct {
	basetypes.ObjectType
}

func (t LinksType) Equal(o attr.Type) bool {
	other, ok := o.(LinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinksType) String() string {
	return "LinksType"
}

func (t LinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return nil, diags
	}

	selfVal, ok := selfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.ObjectValue, was: %T`, selfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinksValue{
		Self:  selfVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLinksValueNull() LinksValue {
	return LinksValue{
		state: attr.ValueStateNull,
	}
}

func NewLinksValueUnknown() LinksValue {
	return LinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinksValue Attribute Value",
				"While creating a LinksValue value, a missing attribute value was detected. "+
					"A LinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinksValue Attribute Type",
				"While creating a LinksValue value, an invalid attribute value was detected. "+
					"A LinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinksValue Attribute Value",
				"While creating a LinksValue value, an extra attribute value was detected. "+
					"A LinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	selfVal, ok := selfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.ObjectValue, was: %T`, selfAttribute))
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	return LinksValue{
		Self:  selfVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinksValue {
	object, diags := NewLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinksValueMust(LinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinksType) ValueType(ctx context.Context) attr.Value {
	return LinksValue{}
}

var _ basetypes.ObjectValuable = LinksValue{}

type LinksValue struct {
	Self  basetypes.ObjectValue `tfsdk:"self"`
	state attr.ValueState
}

func (v LinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["self"] = basetypes.ObjectType{
		AttrTypes: SelfValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Self.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["self"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinksValue) String() string {
	return "LinksValue"
}

func (v LinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var self basetypes.ObjectValue

	if v.Self.IsNull() {
		self = types.ObjectNull(
			SelfValue{}.AttributeTypes(ctx),
		)
	}

	if v.Self.IsUnknown() {
		self = types.ObjectUnknown(
			SelfValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Self.IsNull() && !v.Self.IsUnknown() {
		self = types.ObjectValueMust(
			SelfValue{}.AttributeTypes(ctx),
			v.Self.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"self": basetypes.ObjectType{
			AttrTypes: SelfValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"self": self,
		})

	return objVal, diags
}

func (v LinksValue) Equal(o attr.Value) bool {
	other, ok := o.(LinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Self.Equal(other.Self) {
		return false
	}

	return true
}

func (v LinksValue) Type(ctx context.Context) attr.Type {
	return LinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"self": basetypes.ObjectType{
			AttrTypes: SelfValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SelfType{}

type SelfType struct {
	basetypes.ObjectType
}

func (t SelfType) Equal(o attr.Type) bool {
	other, ok := o.(SelfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SelfType) String() string {
	return "SelfType"
}

func (t SelfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	describedbyAttribute, ok := attributes["describedby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`describedby is missing from object`)

		return nil, diags
	}

	describedbyVal, ok := describedbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`describedby expected to be basetypes.StringValue, was: %T`, describedbyAttribute))
	}

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return nil, diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	hreflangAttribute, ok := attributes["hreflang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hreflang is missing from object`)

		return nil, diags
	}

	hreflangVal, ok := hreflangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hreflang expected to be basetypes.StringValue, was: %T`, hreflangAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return nil, diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return nil, diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return nil, diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SelfValue{
		Describedby: describedbyVal,
		Href:        hrefVal,
		Hreflang:    hreflangVal,
		Meta:        metaVal,
		Rel:         relVal,
		Title:       titleVal,
		SelfType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSelfValueNull() SelfValue {
	return SelfValue{
		state: attr.ValueStateNull,
	}
}

func NewSelfValueUnknown() SelfValue {
	return SelfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSelfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SelfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SelfValue Attribute Value",
				"While creating a SelfValue value, a missing attribute value was detected. "+
					"A SelfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SelfValue Attribute Type",
				"While creating a SelfValue value, an invalid attribute value was detected. "+
					"A SelfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SelfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SelfValue Attribute Value",
				"While creating a SelfValue value, an extra attribute value was detected. "+
					"A SelfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SelfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSelfValueUnknown(), diags
	}

	describedbyAttribute, ok := attributes["describedby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`describedby is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	describedbyVal, ok := describedbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`describedby expected to be basetypes.StringValue, was: %T`, describedbyAttribute))
	}

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	hreflangAttribute, ok := attributes["hreflang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hreflang is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	hreflangVal, ok := hreflangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hreflang expected to be basetypes.StringValue, was: %T`, hreflangAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSelfValueUnknown(), diags
	}

	return SelfValue{
		Describedby: describedbyVal,
		Href:        hrefVal,
		Hreflang:    hreflangVal,
		Meta:        metaVal,
		Rel:         relVal,
		Title:       titleVal,
		SelfType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSelfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SelfValue {
	object, diags := NewSelfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSelfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SelfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSelfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSelfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSelfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSelfValueMust(SelfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SelfType) ValueType(ctx context.Context) attr.Value {
	return SelfValue{}
}

var _ basetypes.ObjectValuable = SelfValue{}

type SelfValue struct {
	Describedby basetypes.StringValue `tfsdk:"describedby"`
	Href        basetypes.StringValue `tfsdk:"href"`
	Hreflang    basetypes.StringValue `tfsdk:"hreflang"`
	Meta        basetypes.ObjectValue `tfsdk:"meta"`
	Rel         basetypes.StringValue `tfsdk:"rel"`
	Title       basetypes.StringValue `tfsdk:"title"`
	SelfType    basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v SelfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["describedby"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["href"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hreflang"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["meta"] = basetypes.ObjectType{
		AttrTypes: MetaValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["rel"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["title"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Describedby.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["describedby"] = val

		val, err = v.Href.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["href"] = val

		val, err = v.Hreflang.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hreflang"] = val

		val, err = v.Meta.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["meta"] = val

		val, err = v.Rel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rel"] = val

		val, err = v.Title.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["title"] = val

		val, err = v.SelfType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SelfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SelfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SelfValue) String() string {
	return "SelfValue"
}

func (v SelfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var meta basetypes.ObjectValue

	if v.Meta.IsNull() {
		meta = types.ObjectNull(
			MetaValue{}.AttributeTypes(ctx),
		)
	}

	if v.Meta.IsUnknown() {
		meta = types.ObjectUnknown(
			MetaValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Meta.IsNull() && !v.Meta.IsUnknown() {
		meta = types.ObjectValueMust(
			MetaValue{}.AttributeTypes(ctx),
			v.Meta.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"describedby": basetypes.StringType{},
		"href":        basetypes.StringType{},
		"hreflang":    basetypes.StringType{},
		"meta": basetypes.ObjectType{
			AttrTypes: MetaValue{}.AttributeTypes(ctx),
		},
		"rel":   basetypes.StringType{},
		"title": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"describedby": v.Describedby,
			"href":        v.Href,
			"hreflang":    v.Hreflang,
			"meta":        meta,
			"rel":         v.Rel,
			"title":       v.Title,
			"type":        v.SelfType,
		})

	return objVal, diags
}

func (v SelfValue) Equal(o attr.Value) bool {
	other, ok := o.(SelfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Describedby.Equal(other.Describedby) {
		return false
	}

	if !v.Href.Equal(other.Href) {
		return false
	}

	if !v.Hreflang.Equal(other.Hreflang) {
		return false
	}

	if !v.Meta.Equal(other.Meta) {
		return false
	}

	if !v.Rel.Equal(other.Rel) {
		return false
	}

	if !v.Title.Equal(other.Title) {
		return false
	}

	if !v.SelfType.Equal(other.SelfType) {
		return false
	}

	return true
}

func (v SelfValue) Type(ctx context.Context) attr.Type {
	return SelfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SelfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"describedby": basetypes.StringType{},
		"href":        basetypes.StringType{},
		"hreflang":    basetypes.StringType{},
		"meta": basetypes.ObjectType{
			AttrTypes: MetaValue{}.AttributeTypes(ctx),
		},
		"rel":   basetypes.StringType{},
		"title": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MetaType{}

type MetaType struct {
	basetypes.ObjectType
}

func (t MetaType) Equal(o attr.Type) bool {
	other, ok := o.(MetaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetaType) String() string {
	return "MetaType"
}

func (t MetaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return MetaValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewMetaValueNull() MetaValue {
	return MetaValue{
		state: attr.ValueStateNull,
	}
}

func NewMetaValueUnknown() MetaValue {
	return MetaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetaValue Attribute Value",
				"While creating a MetaValue value, a missing attribute value was detected. "+
					"A MetaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetaValue Attribute Type",
				"While creating a MetaValue value, an invalid attribute value was detected. "+
					"A MetaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetaValue Attribute Value",
				"While creating a MetaValue value, an extra attribute value was detected. "+
					"A MetaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	return MetaValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewMetaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetaValue {
	object, diags := NewMetaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetaValueMust(MetaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetaType) ValueType(ctx context.Context) attr.Value {
	return MetaValue{}
}

var _ basetypes.ObjectValuable = MetaValue{}

type MetaValue struct {
	state attr.ValueState
}

func (v MetaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetaValue) String() string {
	return "MetaValue"
}

func (v MetaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v MetaValue) Equal(o attr.Value) bool {
	other, ok := o.(MetaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v MetaValue) Type(ctx context.Context) attr.Type {
	return MetaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = RelationshipsType{}

type RelationshipsType struct {
	basetypes.ObjectType
}

func (t RelationshipsType) Equal(o attr.Type) bool {
	other, ok := o.(RelationshipsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RelationshipsType) String() string {
	return "RelationshipsType"
}

func (t RelationshipsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ObjectValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RelationshipsValue{
		Tags:  tagsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRelationshipsValueNull() RelationshipsValue {
	return RelationshipsValue{
		state: attr.ValueStateNull,
	}
}

func NewRelationshipsValueUnknown() RelationshipsValue {
	return RelationshipsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRelationshipsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RelationshipsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RelationshipsValue Attribute Value",
				"While creating a RelationshipsValue value, a missing attribute value was detected. "+
					"A RelationshipsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RelationshipsValue Attribute Type",
				"While creating a RelationshipsValue value, an invalid attribute value was detected. "+
					"A RelationshipsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RelationshipsValue Attribute Value",
				"While creating a RelationshipsValue value, an extra attribute value was detected. "+
					"A RelationshipsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RelationshipsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRelationshipsValueUnknown(), diags
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewRelationshipsValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ObjectValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return NewRelationshipsValueUnknown(), diags
	}

	return RelationshipsValue{
		Tags:  tagsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRelationshipsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RelationshipsValue {
	object, diags := NewRelationshipsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRelationshipsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RelationshipsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRelationshipsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRelationshipsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRelationshipsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRelationshipsValueMust(RelationshipsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RelationshipsType) ValueType(ctx context.Context) attr.Value {
	return RelationshipsValue{}
}

var _ basetypes.ObjectValuable = RelationshipsValue{}

type RelationshipsValue struct {
	Tags  basetypes.ObjectValue `tfsdk:"tags"`
	state attr.ValueState
}

func (v RelationshipsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["tags"] = basetypes.ObjectType{
		AttrTypes: TagsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RelationshipsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RelationshipsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RelationshipsValue) String() string {
	return "RelationshipsValue"
}

func (v RelationshipsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var tags basetypes.ObjectValue

	if v.Tags.IsNull() {
		tags = types.ObjectNull(
			TagsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Tags.IsUnknown() {
		tags = types.ObjectUnknown(
			TagsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Tags.IsNull() && !v.Tags.IsUnknown() {
		tags = types.ObjectValueMust(
			TagsValue{}.AttributeTypes(ctx),
			v.Tags.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"tags": basetypes.ObjectType{
			AttrTypes: TagsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"tags": tags,
		})

	return objVal, diags
}

func (v RelationshipsValue) Equal(o attr.Value) bool {
	other, ok := o.(RelationshipsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	return true
}

func (v RelationshipsValue) Type(ctx context.Context) attr.Type {
	return RelationshipsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RelationshipsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"tags": basetypes.ObjectType{
			AttrTypes: TagsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = TagsType{}

type TagsType struct {
	basetypes.ObjectType
}

func (t TagsType) Equal(o attr.Type) bool {
	other, ok := o.(TagsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TagsType) String() string {
	return "TagsType"
}

func (t TagsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return nil, diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TagsValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTagsValueNull() TagsValue {
	return TagsValue{
		state: attr.ValueStateNull,
	}
}

func NewTagsValueUnknown() TagsValue {
	return TagsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTagsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TagsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TagsValue Attribute Value",
				"While creating a TagsValue value, a missing attribute value was detected. "+
					"A TagsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TagsValue Attribute Type",
				"While creating a TagsValue value, an invalid attribute value was detected. "+
					"A TagsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TagsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TagsValue Attribute Value",
				"While creating a TagsValue value, an extra attribute value was detected. "+
					"A TagsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TagsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return NewTagsValueUnknown(), diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	return TagsValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTagsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TagsValue {
	object, diags := NewTagsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTagsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TagsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTagsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTagsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTagsValueMust(TagsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TagsType) ValueType(ctx context.Context) attr.Value {
	return TagsValue{}
}

var _ basetypes.ObjectValuable = TagsValue{}

type TagsValue struct {
	Data  basetypes.ListValue `tfsdk:"data"`
	state attr.ValueState
}

func (v TagsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["data"] = basetypes.ListType{
		ElemType: DataValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Data.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TagsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TagsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TagsValue) String() string {
	return "TagsValue"
}

func (v TagsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	data := types.ListValueMust(
		DataType{
			basetypes.ObjectType{
				AttrTypes: DataValue{}.AttributeTypes(ctx),
			},
		},
		v.Data.Elements(),
	)

	if v.Data.IsNull() {
		data = types.ListNull(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Data.IsUnknown() {
		data = types.ListUnknown(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"data": basetypes.ListType{
			ElemType: DataValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data": data,
		})

	return objVal, diags
}

func (v TagsValue) Equal(o attr.Value) bool {
	other, ok := o.(TagsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Data.Equal(other.Data) {
		return false
	}

	return true
}

func (v TagsValue) Type(ctx context.Context) attr.Type {
	return TagsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TagsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data": basetypes.ListType{
			ElemType: DataValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Id       basetypes.StringValue `tfsdk:"id"`
	DataType basetypes.StringValue `tfsdk:"type"`
	state    attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":   v.Id,
			"type": v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = HetznerType{}

type HetznerType struct {
	basetypes.ObjectType
}

func (t HetznerType) Equal(o attr.Type) bool {
	other, ok := o.(HetznerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HetznerType) String() string {
	return "HetznerType"
}

func (t HetznerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enableDailyBackupsAttribute, ok := attributes["enable_daily_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_daily_backups is missing from object`)

		return nil, diags
	}

	enableDailyBackupsVal, ok := enableDailyBackupsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_daily_backups expected to be basetypes.StringValue, was: %T`, enableDailyBackupsAttribute))
	}

	networkIdAttribute, ok := attributes["network_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_id is missing from object`)

		return nil, diags
	}

	networkIdVal, ok := networkIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_id expected to be basetypes.StringValue, was: %T`, networkIdAttribute))
	}

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return nil, diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return nil, diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HetznerValue{
		EnableDailyBackups: enableDailyBackupsVal,
		NetworkId:          networkIdVal,
		RegionId:           regionIdVal,
		SizeId:             sizeIdVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewHetznerValueNull() HetznerValue {
	return HetznerValue{
		state: attr.ValueStateNull,
	}
}

func NewHetznerValueUnknown() HetznerValue {
	return HetznerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHetznerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HetznerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HetznerValue Attribute Value",
				"While creating a HetznerValue value, a missing attribute value was detected. "+
					"A HetznerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HetznerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HetznerValue Attribute Type",
				"While creating a HetznerValue value, an invalid attribute value was detected. "+
					"A HetznerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HetznerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HetznerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HetznerValue Attribute Value",
				"While creating a HetznerValue value, an extra attribute value was detected. "+
					"A HetznerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HetznerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHetznerValueUnknown(), diags
	}

	enableDailyBackupsAttribute, ok := attributes["enable_daily_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_daily_backups is missing from object`)

		return NewHetznerValueUnknown(), diags
	}

	enableDailyBackupsVal, ok := enableDailyBackupsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_daily_backups expected to be basetypes.StringValue, was: %T`, enableDailyBackupsAttribute))
	}

	networkIdAttribute, ok := attributes["network_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_id is missing from object`)

		return NewHetznerValueUnknown(), diags
	}

	networkIdVal, ok := networkIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_id expected to be basetypes.StringValue, was: %T`, networkIdAttribute))
	}

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return NewHetznerValueUnknown(), diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return NewHetznerValueUnknown(), diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	if diags.HasError() {
		return NewHetznerValueUnknown(), diags
	}

	return HetznerValue{
		EnableDailyBackups: enableDailyBackupsVal,
		NetworkId:          networkIdVal,
		RegionId:           regionIdVal,
		SizeId:             sizeIdVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewHetznerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HetznerValue {
	object, diags := NewHetznerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHetznerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HetznerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHetznerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHetznerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHetznerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHetznerValueMust(HetznerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HetznerType) ValueType(ctx context.Context) attr.Value {
	return HetznerValue{}
}

var _ basetypes.ObjectValuable = HetznerValue{}

type HetznerValue struct {
	EnableDailyBackups basetypes.StringValue `tfsdk:"enable_daily_backups"`
	NetworkId          basetypes.StringValue `tfsdk:"network_id"`
	RegionId           basetypes.StringValue `tfsdk:"region_id"`
	SizeId             basetypes.StringValue `tfsdk:"size_id"`
	state              attr.ValueState
}

func (v HetznerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enable_daily_backups"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.EnableDailyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_daily_backups"] = val

		val, err = v.NetworkId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_id"] = val

		val, err = v.RegionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region_id"] = val

		val, err = v.SizeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HetznerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HetznerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HetznerValue) String() string {
	return "HetznerValue"
}

func (v HetznerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enable_daily_backups": basetypes.StringType{},
		"network_id":           basetypes.StringType{},
		"region_id":            basetypes.StringType{},
		"size_id":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enable_daily_backups": v.EnableDailyBackups,
			"network_id":           v.NetworkId,
			"region_id":            v.RegionId,
			"size_id":              v.SizeId,
		})

	return objVal, diags
}

func (v HetznerValue) Equal(o attr.Value) bool {
	other, ok := o.(HetznerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EnableDailyBackups.Equal(other.EnableDailyBackups) {
		return false
	}

	if !v.NetworkId.Equal(other.NetworkId) {
		return false
	}

	if !v.RegionId.Equal(other.RegionId) {
		return false
	}

	if !v.SizeId.Equal(other.SizeId) {
		return false
	}

	return true
}

func (v HetznerValue) Type(ctx context.Context) attr.Type {
	return HetznerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HetznerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enable_daily_backups": basetypes.StringType{},
		"network_id":           basetypes.StringType{},
		"region_id":            basetypes.StringType{},
		"size_id":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LaravelType{}

type LaravelType struct {
	basetypes.ObjectType
}

func (t LaravelType) Equal(o attr.Type) bool {
	other, ok := o.(LaravelType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LaravelType) String() string {
	return "LaravelType"
}

func (t LaravelType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return nil, diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return nil, diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	vpcUuidAttribute, ok := attributes["vpc_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc_uuid is missing from object`)

		return nil, diags
	}

	vpcUuidVal, ok := vpcUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc_uuid expected to be basetypes.StringValue, was: %T`, vpcUuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LaravelValue{
		RegionId: regionIdVal,
		SizeId:   sizeIdVal,
		VpcUuid:  vpcUuidVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewLaravelValueNull() LaravelValue {
	return LaravelValue{
		state: attr.ValueStateNull,
	}
}

func NewLaravelValueUnknown() LaravelValue {
	return LaravelValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLaravelValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LaravelValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LaravelValue Attribute Value",
				"While creating a LaravelValue value, a missing attribute value was detected. "+
					"A LaravelValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LaravelValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LaravelValue Attribute Type",
				"While creating a LaravelValue value, an invalid attribute value was detected. "+
					"A LaravelValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LaravelValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LaravelValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LaravelValue Attribute Value",
				"While creating a LaravelValue value, an extra attribute value was detected. "+
					"A LaravelValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LaravelValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLaravelValueUnknown(), diags
	}

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return NewLaravelValueUnknown(), diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return NewLaravelValueUnknown(), diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	vpcUuidAttribute, ok := attributes["vpc_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc_uuid is missing from object`)

		return NewLaravelValueUnknown(), diags
	}

	vpcUuidVal, ok := vpcUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc_uuid expected to be basetypes.StringValue, was: %T`, vpcUuidAttribute))
	}

	if diags.HasError() {
		return NewLaravelValueUnknown(), diags
	}

	return LaravelValue{
		RegionId: regionIdVal,
		SizeId:   sizeIdVal,
		VpcUuid:  vpcUuidVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewLaravelValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LaravelValue {
	object, diags := NewLaravelValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLaravelValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LaravelType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLaravelValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLaravelValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLaravelValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLaravelValueMust(LaravelValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LaravelType) ValueType(ctx context.Context) attr.Value {
	return LaravelValue{}
}

var _ basetypes.ObjectValuable = LaravelValue{}

type LaravelValue struct {
	RegionId basetypes.StringValue `tfsdk:"region_id"`
	SizeId   basetypes.StringValue `tfsdk:"size_id"`
	VpcUuid  basetypes.StringValue `tfsdk:"vpc_uuid"`
	state    attr.ValueState
}

func (v LaravelValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["region_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vpc_uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.RegionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region_id"] = val

		val, err = v.SizeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_id"] = val

		val, err = v.VpcUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpc_uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LaravelValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LaravelValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LaravelValue) String() string {
	return "LaravelValue"
}

func (v LaravelValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"region_id": basetypes.StringType{},
		"size_id":   basetypes.StringType{},
		"vpc_uuid":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"region_id": v.RegionId,
			"size_id":   v.SizeId,
			"vpc_uuid":  v.VpcUuid,
		})

	return objVal, diags
}

func (v LaravelValue) Equal(o attr.Value) bool {
	other, ok := o.(LaravelValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.RegionId.Equal(other.RegionId) {
		return false
	}

	if !v.SizeId.Equal(other.SizeId) {
		return false
	}

	if !v.VpcUuid.Equal(other.VpcUuid) {
		return false
	}

	return true
}

func (v LaravelValue) Type(ctx context.Context) attr.Type {
	return LaravelType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LaravelValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"region_id": basetypes.StringType{},
		"size_id":   basetypes.StringType{},
		"vpc_uuid":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ocean2Type{}

type Ocean2Type struct {
	basetypes.ObjectType
}

func (t Ocean2Type) Equal(o attr.Type) bool {
	other, ok := o.(Ocean2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ocean2Type) String() string {
	return "Ocean2Type"
}

func (t Ocean2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enableWeeklyBackupsAttribute, ok := attributes["enable_weekly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_weekly_backups is missing from object`)

		return nil, diags
	}

	enableWeeklyBackupsVal, ok := enableWeeklyBackupsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_weekly_backups expected to be basetypes.StringValue, was: %T`, enableWeeklyBackupsAttribute))
	}

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return nil, diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return nil, diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	vpcUuidAttribute, ok := attributes["vpc_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc_uuid is missing from object`)

		return nil, diags
	}

	vpcUuidVal, ok := vpcUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc_uuid expected to be basetypes.StringValue, was: %T`, vpcUuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ocean2Value{
		EnableWeeklyBackups: enableWeeklyBackupsVal,
		RegionId:            regionIdVal,
		SizeId:              sizeIdVal,
		VpcUuid:             vpcUuidVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewOcean2ValueNull() Ocean2Value {
	return Ocean2Value{
		state: attr.ValueStateNull,
	}
}

func NewOcean2ValueUnknown() Ocean2Value {
	return Ocean2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewOcean2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ocean2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ocean2Value Attribute Value",
				"While creating a Ocean2Value value, a missing attribute value was detected. "+
					"A Ocean2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ocean2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ocean2Value Attribute Type",
				"While creating a Ocean2Value value, an invalid attribute value was detected. "+
					"A Ocean2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ocean2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ocean2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ocean2Value Attribute Value",
				"While creating a Ocean2Value value, an extra attribute value was detected. "+
					"A Ocean2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ocean2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOcean2ValueUnknown(), diags
	}

	enableWeeklyBackupsAttribute, ok := attributes["enable_weekly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_weekly_backups is missing from object`)

		return NewOcean2ValueUnknown(), diags
	}

	enableWeeklyBackupsVal, ok := enableWeeklyBackupsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_weekly_backups expected to be basetypes.StringValue, was: %T`, enableWeeklyBackupsAttribute))
	}

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return NewOcean2ValueUnknown(), diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return NewOcean2ValueUnknown(), diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	vpcUuidAttribute, ok := attributes["vpc_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc_uuid is missing from object`)

		return NewOcean2ValueUnknown(), diags
	}

	vpcUuidVal, ok := vpcUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc_uuid expected to be basetypes.StringValue, was: %T`, vpcUuidAttribute))
	}

	if diags.HasError() {
		return NewOcean2ValueUnknown(), diags
	}

	return Ocean2Value{
		EnableWeeklyBackups: enableWeeklyBackupsVal,
		RegionId:            regionIdVal,
		SizeId:              sizeIdVal,
		VpcUuid:             vpcUuidVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewOcean2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ocean2Value {
	object, diags := NewOcean2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOcean2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ocean2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOcean2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOcean2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOcean2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOcean2ValueMust(Ocean2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ocean2Type) ValueType(ctx context.Context) attr.Value {
	return Ocean2Value{}
}

var _ basetypes.ObjectValuable = Ocean2Value{}

type Ocean2Value struct {
	EnableWeeklyBackups basetypes.StringValue `tfsdk:"enable_weekly_backups"`
	RegionId            basetypes.StringValue `tfsdk:"region_id"`
	SizeId              basetypes.StringValue `tfsdk:"size_id"`
	VpcUuid             basetypes.StringValue `tfsdk:"vpc_uuid"`
	state               attr.ValueState
}

func (v Ocean2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enable_weekly_backups"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vpc_uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.EnableWeeklyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_weekly_backups"] = val

		val, err = v.RegionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region_id"] = val

		val, err = v.SizeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_id"] = val

		val, err = v.VpcUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpc_uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ocean2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ocean2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ocean2Value) String() string {
	return "Ocean2Value"
}

func (v Ocean2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enable_weekly_backups": basetypes.StringType{},
		"region_id":             basetypes.StringType{},
		"size_id":               basetypes.StringType{},
		"vpc_uuid":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enable_weekly_backups": v.EnableWeeklyBackups,
			"region_id":             v.RegionId,
			"size_id":               v.SizeId,
			"vpc_uuid":              v.VpcUuid,
		})

	return objVal, diags
}

func (v Ocean2Value) Equal(o attr.Value) bool {
	other, ok := o.(Ocean2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EnableWeeklyBackups.Equal(other.EnableWeeklyBackups) {
		return false
	}

	if !v.RegionId.Equal(other.RegionId) {
		return false
	}

	if !v.SizeId.Equal(other.SizeId) {
		return false
	}

	if !v.VpcUuid.Equal(other.VpcUuid) {
		return false
	}

	return true
}

func (v Ocean2Value) Type(ctx context.Context) attr.Type {
	return Ocean2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ocean2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enable_weekly_backups": basetypes.StringType{},
		"region_id":             basetypes.StringType{},
		"size_id":               basetypes.StringType{},
		"vpc_uuid":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VultrType{}

type VultrType struct {
	basetypes.ObjectType
}

func (t VultrType) Equal(o attr.Type) bool {
	other, ok := o.(VultrType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VultrType) String() string {
	return "VultrType"
}

func (t VultrType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	networkIdAttribute, ok := attributes["network_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_id is missing from object`)

		return nil, diags
	}

	networkIdVal, ok := networkIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_id expected to be basetypes.StringValue, was: %T`, networkIdAttribute))
	}

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return nil, diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return nil, diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VultrValue{
		NetworkId: networkIdVal,
		RegionId:  regionIdVal,
		SizeId:    sizeIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVultrValueNull() VultrValue {
	return VultrValue{
		state: attr.ValueStateNull,
	}
}

func NewVultrValueUnknown() VultrValue {
	return VultrValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVultrValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VultrValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VultrValue Attribute Value",
				"While creating a VultrValue value, a missing attribute value was detected. "+
					"A VultrValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VultrValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VultrValue Attribute Type",
				"While creating a VultrValue value, an invalid attribute value was detected. "+
					"A VultrValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VultrValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VultrValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VultrValue Attribute Value",
				"While creating a VultrValue value, an extra attribute value was detected. "+
					"A VultrValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VultrValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVultrValueUnknown(), diags
	}

	networkIdAttribute, ok := attributes["network_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_id is missing from object`)

		return NewVultrValueUnknown(), diags
	}

	networkIdVal, ok := networkIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_id expected to be basetypes.StringValue, was: %T`, networkIdAttribute))
	}

	regionIdAttribute, ok := attributes["region_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_id is missing from object`)

		return NewVultrValueUnknown(), diags
	}

	regionIdVal, ok := regionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_id expected to be basetypes.StringValue, was: %T`, regionIdAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return NewVultrValueUnknown(), diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.StringValue, was: %T`, sizeIdAttribute))
	}

	if diags.HasError() {
		return NewVultrValueUnknown(), diags
	}

	return VultrValue{
		NetworkId: networkIdVal,
		RegionId:  regionIdVal,
		SizeId:    sizeIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVultrValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VultrValue {
	object, diags := NewVultrValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVultrValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VultrType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVultrValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVultrValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVultrValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVultrValueMust(VultrValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VultrType) ValueType(ctx context.Context) attr.Value {
	return VultrValue{}
}

var _ basetypes.ObjectValuable = VultrValue{}

type VultrValue struct {
	NetworkId basetypes.StringValue `tfsdk:"network_id"`
	RegionId  basetypes.StringValue `tfsdk:"region_id"`
	SizeId    basetypes.StringValue `tfsdk:"size_id"`
	state     attr.ValueState
}

func (v VultrValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["network_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.NetworkId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_id"] = val

		val, err = v.RegionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region_id"] = val

		val, err = v.SizeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VultrValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VultrValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VultrValue) String() string {
	return "VultrValue"
}

func (v VultrValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"network_id": basetypes.StringType{},
		"region_id":  basetypes.StringType{},
		"size_id":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"network_id": v.NetworkId,
			"region_id":  v.RegionId,
			"size_id":    v.SizeId,
		})

	return objVal, diags
}

func (v VultrValue) Equal(o attr.Value) bool {
	other, ok := o.(VultrValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NetworkId.Equal(other.NetworkId) {
		return false
	}

	if !v.RegionId.Equal(other.RegionId) {
		return false
	}

	if !v.SizeId.Equal(other.SizeId) {
		return false
	}

	return true
}

func (v VultrValue) Type(ctx context.Context) attr.Type {
	return VultrType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VultrValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"network_id": basetypes.StringType{},
		"region_id":  basetypes.StringType{},
		"size_id":    basetypes.StringType{},
	}
}
