// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_sites

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func SitesResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"allow_wildcard_subdomains": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"branch": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"attributes": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"aliases": schema.ListAttribute{
								ElementType: types.StringType,
								Computed:    true,
							},
							"app_type": schema.StringAttribute{
								Computed: true,
							},
							"created_at": schema.StringAttribute{
								Computed: true,
							},
							"database": schema.StringAttribute{
								Computed: true,
							},
							"deployment_script": schema.StringAttribute{
								Computed: true,
							},
							"deployment_status": schema.StringAttribute{
								Computed: true,
							},
							"deployment_url": schema.StringAttribute{
								Computed: true,
							},
							"healthcheck_url": schema.StringAttribute{
								Computed: true,
							},
							"https": schema.BoolAttribute{
								Computed: true,
							},
							"isolated": schema.BoolAttribute{
								Computed: true,
							},
							"maintenance_mode": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"enabled": schema.BoolAttribute{
										Computed: true,
									},
									"status": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: MaintenanceModeType{
									ObjectType: types.ObjectType{
										AttrTypes: MaintenanceModeValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"php_version": schema.StringAttribute{
								Computed: true,
							},
							"quick_deploy": schema.BoolAttribute{
								Computed: true,
							},
							"repository": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"branch": schema.StringAttribute{
										Computed: true,
									},
									"provider": schema.StringAttribute{
										Computed: true,
									},
									"status": schema.StringAttribute{
										Computed: true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: RepositoryType{
									ObjectType: types.ObjectType{
										AttrTypes: RepositoryValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
							"root_directory": schema.StringAttribute{
								Computed: true,
							},
							"shared_paths": schema.MapAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "* The linked directories for the site.",
								MarkdownDescription: "* The linked directories for the site.",
							},
							"status": schema.StringAttribute{
								Computed: true,
							},
							"updated_at": schema.StringAttribute{
								Computed: true,
							},
							"url": schema.StringAttribute{
								Computed: true,
							},
							"user": schema.StringAttribute{
								Computed: true,
							},
							"uses_envoyer": schema.BoolAttribute{
								Computed: true,
							},
							"web_directory": schema.StringAttribute{
								Computed: true,
							},
							"wildcards": schema.BoolAttribute{
								Computed: true,
							},
							"zero_downtime_deployments": schema.BoolAttribute{
								Computed: true,
							},
						},
						CustomType: AttributesType{
							ObjectType: types.ObjectType{
								AttrTypes: AttributesValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"links": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"self": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"describedby": schema.StringAttribute{
										Computed: true,
									},
									"href": schema.StringAttribute{
										Computed: true,
									},
									"hreflang": schema.StringAttribute{
										Computed:            true,
										Description:         "Language of the target link",
										MarkdownDescription: "Language of the target link",
									},
									"meta": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{},
										CustomType: MetaType{
											ObjectType: types.ObjectType{
												AttrTypes: MetaValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"rel": schema.StringAttribute{
										Computed: true,
									},
									"title": schema.StringAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: SelfType{
									ObjectType: types.ObjectType{
										AttrTypes: SelfValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
						},
						CustomType: LinksType{
							ObjectType: types.ObjectType{
								AttrTypes: LinksValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"relationships": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"latest_deployment": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"data": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"id": schema.StringAttribute{
												Computed: true,
											},
											"type": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: DataType{
											ObjectType: types.ObjectType{
												AttrTypes: DataValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
								},
								CustomType: LatestDeploymentType{
									ObjectType: types.ObjectType{
										AttrTypes: LatestDeploymentValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
							"redirect_rules": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"data": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Computed: true,
												},
												"type": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: DataType{
												ObjectType: types.ObjectType{
													AttrTypes: DataValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
								},
								CustomType: RedirectRulesType{
									ObjectType: types.ObjectType{
										AttrTypes: RedirectRulesValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
							"security_rules": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"data": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Computed: true,
												},
												"type": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: DataType{
												ObjectType: types.ObjectType{
													AttrTypes: DataValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
								},
								CustomType: SecurityRulesType{
									ObjectType: types.ObjectType{
										AttrTypes: SecurityRulesValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
							"server": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"data": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"id": schema.StringAttribute{
												Computed: true,
											},
											"type": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: DataType{
											ObjectType: types.ObjectType{
												AttrTypes: DataValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
								},
								CustomType: ServerType{
									ObjectType: types.ObjectType{
										AttrTypes: ServerValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
							"tags": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"data": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Computed: true,
												},
												"type": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: DataType{
												ObjectType: types.ObjectType{
													AttrTypes: DataValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
								},
								CustomType: TagsType{
									ObjectType: types.ObjectType{
										AttrTypes: TagsValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
						},
						CustomType: RelationshipsType{
							ObjectType: types.ObjectType{
								AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"type": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"database_id": schema.Int64Attribute{
				Optional: true,
				Computed: true,
			},
			"database_user_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"domain_mode": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"on-forge",
						"custom",
					),
				},
			},
			"frontend_build_command": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The build command for frontend assets.",
				MarkdownDescription: "The build command for frontend assets.",
			},
			"frontend_package_manager": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The package manager for frontend applications.",
				MarkdownDescription: "The package manager for frontend applications.",
			},
			"generate_deploy_key": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"install_composer_dependencies": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"is_isolated": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"isolated_user": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"name": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"nginx_template_id": schema.Int64Attribute{
				Optional: true,
				Computed: true,
			},
			"nuxt_next_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The render mode for Next/Nuxt applications.",
				MarkdownDescription: "The render mode for Next/Nuxt applications.",
			},
			"nuxt_next_port": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The port used for Next/Nuxt applications.",
				MarkdownDescription: "The port used for Next/Nuxt applications.",
			},
			"organization": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The organization slug",
				MarkdownDescription: "The organization slug",
			},
			"php_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"php5",
						"php56-old",
						"php56",
						"php70",
						"php71",
						"php72",
						"php73",
						"php74",
						"php80",
						"php81",
						"php82",
						"php83",
						"php84",
						"php85",
					),
				},
			},
			"private_deploy_key": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"public_deploy_key": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"push_to_deploy": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Automatically trigger a new deployment when changes are pushed to the environment's Git branch.",
				MarkdownDescription: "Automatically trigger a new deployment when changes are pushed to the environment's Git branch.",
				Default:             booldefault.StaticBool(false),
			},
			"repository": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"root_directory": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"shared_paths": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"from": schema.StringAttribute{
							Required:            true,
							Description:         "The path relative to the project's root directory on the server that should be shared between releases.",
							MarkdownDescription: "The path relative to the project's root directory on the server that should be shared between releases.",
						},
						"to": schema.StringAttribute{
							Required:            true,
							Description:         "The path relative to the deployment's release directory that the shared path should be linked to.",
							MarkdownDescription: "The path relative to the deployment's release directory that the shared path should be linked to.",
						},
					},
					CustomType: SharedPathsType{
						ObjectType: types.ObjectType{
							AttrTypes: SharedPathsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "A list of files or directories to be shared between releases for zero-downtime deployments.",
				MarkdownDescription: "A list of files or directories to be shared between releases for zero-downtime deployments.",
			},
			"site": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The site ID",
				MarkdownDescription: "The site ID",
			},
			"source_control_provider": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "All supported source control providers.\n",
				MarkdownDescription: "All supported source control providers.\n",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"github",
						"gitlab",
						"bitbucket",
						"gitlab-custom",
						"custom",
					),
				},
			},
			"statamic_setup": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The type of setup for Statmic apps.",
				MarkdownDescription: "The type of setup for Statmic apps.",
			},
			"statamic_starter_kit": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The starter kit for the Statamic app.",
				MarkdownDescription: "The starter kit for the Statamic app.",
			},
			"statamic_super_user_email": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"statamic_super_user_password": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"tags": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"type": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"laravel",
						"symfony",
						"statamic",
						"wordpress",
						"phpmyadmin",
						"php",
						"nextjs",
						"nuxtjs",
						"static-html",
						"other",
						"custom",
					),
				},
			},
			"web_directory": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"www_redirect_type": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"zero_downtime_deployments": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
		},
	}
}

type SitesModel struct {
	AllowWildcardSubdomains     types.String `tfsdk:"allow_wildcard_subdomains"`
	Branch                      types.String `tfsdk:"branch"`
	Data                        DataValue    `tfsdk:"data"`
	DatabaseId                  types.Int64  `tfsdk:"database_id"`
	DatabaseUserId              types.String `tfsdk:"database_user_id"`
	DomainMode                  types.String `tfsdk:"domain_mode"`
	FrontendBuildCommand        types.String `tfsdk:"frontend_build_command"`
	FrontendPackageManager      types.String `tfsdk:"frontend_package_manager"`
	GenerateDeployKey           types.Bool   `tfsdk:"generate_deploy_key"`
	InstallComposerDependencies types.Bool   `tfsdk:"install_composer_dependencies"`
	IsIsolated                  types.Bool   `tfsdk:"is_isolated"`
	IsolatedUser                types.String `tfsdk:"isolated_user"`
	Name                        types.String `tfsdk:"name"`
	NginxTemplateId             types.Int64  `tfsdk:"nginx_template_id"`
	NuxtNextMode                types.String `tfsdk:"nuxt_next_mode"`
	NuxtNextPort                types.Int64  `tfsdk:"nuxt_next_port"`
	Organization                types.String `tfsdk:"organization"`
	PhpVersion                  types.String `tfsdk:"php_version"`
	PrivateDeployKey            types.String `tfsdk:"private_deploy_key"`
	PublicDeployKey             types.String `tfsdk:"public_deploy_key"`
	PushToDeploy                types.Bool   `tfsdk:"push_to_deploy"`
	Repository                  types.String `tfsdk:"repository"`
	RootDirectory               types.String `tfsdk:"root_directory"`
	SharedPaths                 types.List   `tfsdk:"shared_paths"`
	Site                        types.Int64  `tfsdk:"site"`
	SourceControlProvider       types.String `tfsdk:"source_control_provider"`
	StatamicSetup               types.String `tfsdk:"statamic_setup"`
	StatamicStarterKit          types.String `tfsdk:"statamic_starter_kit"`
	StatamicSuperUserEmail      types.String `tfsdk:"statamic_super_user_email"`
	StatamicSuperUserPassword   types.String `tfsdk:"statamic_super_user_password"`
	Tags                        types.List   `tfsdk:"tags"`
	Type                        types.String `tfsdk:"type"`
	WebDirectory                types.String `tfsdk:"web_directory"`
	WwwRedirectType             types.String `tfsdk:"www_redirect_type"`
	ZeroDowntimeDeployments     types.Bool   `tfsdk:"zero_downtime_deployments"`
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return nil, diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.ObjectValue, was: %T`, attributesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return nil, diags
	}

	linksVal, ok := linksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ObjectValue, was: %T`, linksAttribute))
	}

	relationshipsAttribute, ok := attributes["relationships"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`relationships is missing from object`)

		return nil, diags
	}

	relationshipsVal, ok := relationshipsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`relationships expected to be basetypes.ObjectValue, was: %T`, relationshipsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Attributes:    attributesVal,
		Id:            idVal,
		Links:         linksVal,
		Relationships: relationshipsVal,
		DataType:      typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return NewDataValueUnknown(), diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.ObjectValue, was: %T`, attributesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return NewDataValueUnknown(), diags
	}

	linksVal, ok := linksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ObjectValue, was: %T`, linksAttribute))
	}

	relationshipsAttribute, ok := attributes["relationships"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`relationships is missing from object`)

		return NewDataValueUnknown(), diags
	}

	relationshipsVal, ok := relationshipsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`relationships expected to be basetypes.ObjectValue, was: %T`, relationshipsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Attributes:    attributesVal,
		Id:            idVal,
		Links:         linksVal,
		Relationships: relationshipsVal,
		DataType:      typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Attributes    basetypes.ObjectValue `tfsdk:"attributes"`
	Id            basetypes.StringValue `tfsdk:"id"`
	Links         basetypes.ObjectValue `tfsdk:"links"`
	Relationships basetypes.ObjectValue `tfsdk:"relationships"`
	DataType      basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["attributes"] = basetypes.ObjectType{
		AttrTypes: AttributesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["links"] = basetypes.ObjectType{
		AttrTypes: LinksValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["relationships"] = basetypes.ObjectType{
		AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Attributes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attributes"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Links.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["links"] = val

		val, err = v.Relationships.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["relationships"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attributes basetypes.ObjectValue

	if v.Attributes.IsNull() {
		attributes = types.ObjectNull(
			AttributesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Attributes.IsUnknown() {
		attributes = types.ObjectUnknown(
			AttributesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Attributes.IsNull() && !v.Attributes.IsUnknown() {
		attributes = types.ObjectValueMust(
			AttributesValue{}.AttributeTypes(ctx),
			v.Attributes.Attributes(),
		)
	}

	var links basetypes.ObjectValue

	if v.Links.IsNull() {
		links = types.ObjectNull(
			LinksValue{}.AttributeTypes(ctx),
		)
	}

	if v.Links.IsUnknown() {
		links = types.ObjectUnknown(
			LinksValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Links.IsNull() && !v.Links.IsUnknown() {
		links = types.ObjectValueMust(
			LinksValue{}.AttributeTypes(ctx),
			v.Links.Attributes(),
		)
	}

	var relationships basetypes.ObjectValue

	if v.Relationships.IsNull() {
		relationships = types.ObjectNull(
			RelationshipsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Relationships.IsUnknown() {
		relationships = types.ObjectUnknown(
			RelationshipsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Relationships.IsNull() && !v.Relationships.IsUnknown() {
		relationships = types.ObjectValueMust(
			RelationshipsValue{}.AttributeTypes(ctx),
			v.Relationships.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"attributes": basetypes.ObjectType{
			AttrTypes: AttributesValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"links": basetypes.ObjectType{
			AttrTypes: LinksValue{}.AttributeTypes(ctx),
		},
		"relationships": basetypes.ObjectType{
			AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attributes":    attributes,
			"id":            v.Id,
			"links":         links,
			"relationships": relationships,
			"type":          v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Attributes.Equal(other.Attributes) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Links.Equal(other.Links) {
		return false
	}

	if !v.Relationships.Equal(other.Relationships) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attributes": basetypes.ObjectType{
			AttrTypes: AttributesValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"links": basetypes.ObjectType{
			AttrTypes: LinksValue{}.AttributeTypes(ctx),
		},
		"relationships": basetypes.ObjectType{
			AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttributesType{}

type AttributesType struct {
	basetypes.ObjectType
}

func (t AttributesType) Equal(o attr.Type) bool {
	other, ok := o.(AttributesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttributesType) String() string {
	return "AttributesType"
}

func (t AttributesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasesAttribute, ok := attributes["aliases"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aliases is missing from object`)

		return nil, diags
	}

	aliasesVal, ok := aliasesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aliases expected to be basetypes.ListValue, was: %T`, aliasesAttribute))
	}

	appTypeAttribute, ok := attributes["app_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_type is missing from object`)

		return nil, diags
	}

	appTypeVal, ok := appTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_type expected to be basetypes.StringValue, was: %T`, appTypeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return nil, diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	deploymentScriptAttribute, ok := attributes["deployment_script"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deployment_script is missing from object`)

		return nil, diags
	}

	deploymentScriptVal, ok := deploymentScriptAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deployment_script expected to be basetypes.StringValue, was: %T`, deploymentScriptAttribute))
	}

	deploymentStatusAttribute, ok := attributes["deployment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deployment_status is missing from object`)

		return nil, diags
	}

	deploymentStatusVal, ok := deploymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deployment_status expected to be basetypes.StringValue, was: %T`, deploymentStatusAttribute))
	}

	deploymentUrlAttribute, ok := attributes["deployment_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deployment_url is missing from object`)

		return nil, diags
	}

	deploymentUrlVal, ok := deploymentUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deployment_url expected to be basetypes.StringValue, was: %T`, deploymentUrlAttribute))
	}

	healthcheckUrlAttribute, ok := attributes["healthcheck_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`healthcheck_url is missing from object`)

		return nil, diags
	}

	healthcheckUrlVal, ok := healthcheckUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`healthcheck_url expected to be basetypes.StringValue, was: %T`, healthcheckUrlAttribute))
	}

	httpsAttribute, ok := attributes["https"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`https is missing from object`)

		return nil, diags
	}

	httpsVal, ok := httpsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`https expected to be basetypes.BoolValue, was: %T`, httpsAttribute))
	}

	isolatedAttribute, ok := attributes["isolated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolated is missing from object`)

		return nil, diags
	}

	isolatedVal, ok := isolatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolated expected to be basetypes.BoolValue, was: %T`, isolatedAttribute))
	}

	maintenanceModeAttribute, ok := attributes["maintenance_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_mode is missing from object`)

		return nil, diags
	}

	maintenanceModeVal, ok := maintenanceModeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_mode expected to be basetypes.ObjectValue, was: %T`, maintenanceModeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	phpVersionAttribute, ok := attributes["php_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`php_version is missing from object`)

		return nil, diags
	}

	phpVersionVal, ok := phpVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`php_version expected to be basetypes.StringValue, was: %T`, phpVersionAttribute))
	}

	quickDeployAttribute, ok := attributes["quick_deploy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quick_deploy is missing from object`)

		return nil, diags
	}

	quickDeployVal, ok := quickDeployAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quick_deploy expected to be basetypes.BoolValue, was: %T`, quickDeployAttribute))
	}

	repositoryAttribute, ok := attributes["repository"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`repository is missing from object`)

		return nil, diags
	}

	repositoryVal, ok := repositoryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`repository expected to be basetypes.ObjectValue, was: %T`, repositoryAttribute))
	}

	rootDirectoryAttribute, ok := attributes["root_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_directory is missing from object`)

		return nil, diags
	}

	rootDirectoryVal, ok := rootDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_directory expected to be basetypes.StringValue, was: %T`, rootDirectoryAttribute))
	}

	sharedPathsAttribute, ok := attributes["shared_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shared_paths is missing from object`)

		return nil, diags
	}

	sharedPathsVal, ok := sharedPathsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shared_paths expected to be basetypes.MapValue, was: %T`, sharedPathsAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	usesEnvoyerAttribute, ok := attributes["uses_envoyer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uses_envoyer is missing from object`)

		return nil, diags
	}

	usesEnvoyerVal, ok := usesEnvoyerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uses_envoyer expected to be basetypes.BoolValue, was: %T`, usesEnvoyerAttribute))
	}

	webDirectoryAttribute, ok := attributes["web_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`web_directory is missing from object`)

		return nil, diags
	}

	webDirectoryVal, ok := webDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`web_directory expected to be basetypes.StringValue, was: %T`, webDirectoryAttribute))
	}

	wildcardsAttribute, ok := attributes["wildcards"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wildcards is missing from object`)

		return nil, diags
	}

	wildcardsVal, ok := wildcardsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wildcards expected to be basetypes.BoolValue, was: %T`, wildcardsAttribute))
	}

	zeroDowntimeDeploymentsAttribute, ok := attributes["zero_downtime_deployments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zero_downtime_deployments is missing from object`)

		return nil, diags
	}

	zeroDowntimeDeploymentsVal, ok := zeroDowntimeDeploymentsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zero_downtime_deployments expected to be basetypes.BoolValue, was: %T`, zeroDowntimeDeploymentsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttributesValue{
		Aliases:                 aliasesVal,
		AppType:                 appTypeVal,
		CreatedAt:               createdAtVal,
		Database:                databaseVal,
		DeploymentScript:        deploymentScriptVal,
		DeploymentStatus:        deploymentStatusVal,
		DeploymentUrl:           deploymentUrlVal,
		HealthcheckUrl:          healthcheckUrlVal,
		Https:                   httpsVal,
		Isolated:                isolatedVal,
		MaintenanceMode:         maintenanceModeVal,
		Name:                    nameVal,
		PhpVersion:              phpVersionVal,
		QuickDeploy:             quickDeployVal,
		Repository:              repositoryVal,
		RootDirectory:           rootDirectoryVal,
		SharedPaths:             sharedPathsVal,
		Status:                  statusVal,
		UpdatedAt:               updatedAtVal,
		Url:                     urlVal,
		User:                    userVal,
		UsesEnvoyer:             usesEnvoyerVal,
		WebDirectory:            webDirectoryVal,
		Wildcards:               wildcardsVal,
		ZeroDowntimeDeployments: zeroDowntimeDeploymentsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueNull() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateNull,
	}
}

func NewAttributesValueUnknown() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAttributesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttributesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttributesValue Attribute Value",
				"While creating a AttributesValue value, a missing attribute value was detected. "+
					"A AttributesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttributesValue Attribute Type",
				"While creating a AttributesValue value, an invalid attribute value was detected. "+
					"A AttributesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttributesValue Attribute Value",
				"While creating a AttributesValue value, an extra attribute value was detected. "+
					"A AttributesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttributesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	aliasesAttribute, ok := attributes["aliases"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aliases is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	aliasesVal, ok := aliasesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aliases expected to be basetypes.ListValue, was: %T`, aliasesAttribute))
	}

	appTypeAttribute, ok := attributes["app_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_type is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	appTypeVal, ok := appTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_type expected to be basetypes.StringValue, was: %T`, appTypeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	databaseAttribute, ok := attributes["database"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	databaseVal, ok := databaseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database expected to be basetypes.StringValue, was: %T`, databaseAttribute))
	}

	deploymentScriptAttribute, ok := attributes["deployment_script"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deployment_script is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	deploymentScriptVal, ok := deploymentScriptAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deployment_script expected to be basetypes.StringValue, was: %T`, deploymentScriptAttribute))
	}

	deploymentStatusAttribute, ok := attributes["deployment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deployment_status is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	deploymentStatusVal, ok := deploymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deployment_status expected to be basetypes.StringValue, was: %T`, deploymentStatusAttribute))
	}

	deploymentUrlAttribute, ok := attributes["deployment_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deployment_url is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	deploymentUrlVal, ok := deploymentUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deployment_url expected to be basetypes.StringValue, was: %T`, deploymentUrlAttribute))
	}

	healthcheckUrlAttribute, ok := attributes["healthcheck_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`healthcheck_url is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	healthcheckUrlVal, ok := healthcheckUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`healthcheck_url expected to be basetypes.StringValue, was: %T`, healthcheckUrlAttribute))
	}

	httpsAttribute, ok := attributes["https"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`https is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	httpsVal, ok := httpsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`https expected to be basetypes.BoolValue, was: %T`, httpsAttribute))
	}

	isolatedAttribute, ok := attributes["isolated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolated is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	isolatedVal, ok := isolatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolated expected to be basetypes.BoolValue, was: %T`, isolatedAttribute))
	}

	maintenanceModeAttribute, ok := attributes["maintenance_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_mode is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	maintenanceModeVal, ok := maintenanceModeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_mode expected to be basetypes.ObjectValue, was: %T`, maintenanceModeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	phpVersionAttribute, ok := attributes["php_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`php_version is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	phpVersionVal, ok := phpVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`php_version expected to be basetypes.StringValue, was: %T`, phpVersionAttribute))
	}

	quickDeployAttribute, ok := attributes["quick_deploy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quick_deploy is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	quickDeployVal, ok := quickDeployAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quick_deploy expected to be basetypes.BoolValue, was: %T`, quickDeployAttribute))
	}

	repositoryAttribute, ok := attributes["repository"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`repository is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	repositoryVal, ok := repositoryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`repository expected to be basetypes.ObjectValue, was: %T`, repositoryAttribute))
	}

	rootDirectoryAttribute, ok := attributes["root_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_directory is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	rootDirectoryVal, ok := rootDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_directory expected to be basetypes.StringValue, was: %T`, rootDirectoryAttribute))
	}

	sharedPathsAttribute, ok := attributes["shared_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shared_paths is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	sharedPathsVal, ok := sharedPathsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shared_paths expected to be basetypes.MapValue, was: %T`, sharedPathsAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	usesEnvoyerAttribute, ok := attributes["uses_envoyer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uses_envoyer is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	usesEnvoyerVal, ok := usesEnvoyerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uses_envoyer expected to be basetypes.BoolValue, was: %T`, usesEnvoyerAttribute))
	}

	webDirectoryAttribute, ok := attributes["web_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`web_directory is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	webDirectoryVal, ok := webDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`web_directory expected to be basetypes.StringValue, was: %T`, webDirectoryAttribute))
	}

	wildcardsAttribute, ok := attributes["wildcards"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wildcards is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	wildcardsVal, ok := wildcardsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wildcards expected to be basetypes.BoolValue, was: %T`, wildcardsAttribute))
	}

	zeroDowntimeDeploymentsAttribute, ok := attributes["zero_downtime_deployments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zero_downtime_deployments is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	zeroDowntimeDeploymentsVal, ok := zeroDowntimeDeploymentsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zero_downtime_deployments expected to be basetypes.BoolValue, was: %T`, zeroDowntimeDeploymentsAttribute))
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	return AttributesValue{
		Aliases:                 aliasesVal,
		AppType:                 appTypeVal,
		CreatedAt:               createdAtVal,
		Database:                databaseVal,
		DeploymentScript:        deploymentScriptVal,
		DeploymentStatus:        deploymentStatusVal,
		DeploymentUrl:           deploymentUrlVal,
		HealthcheckUrl:          healthcheckUrlVal,
		Https:                   httpsVal,
		Isolated:                isolatedVal,
		MaintenanceMode:         maintenanceModeVal,
		Name:                    nameVal,
		PhpVersion:              phpVersionVal,
		QuickDeploy:             quickDeployVal,
		Repository:              repositoryVal,
		RootDirectory:           rootDirectoryVal,
		SharedPaths:             sharedPathsVal,
		Status:                  statusVal,
		UpdatedAt:               updatedAtVal,
		Url:                     urlVal,
		User:                    userVal,
		UsesEnvoyer:             usesEnvoyerVal,
		WebDirectory:            webDirectoryVal,
		Wildcards:               wildcardsVal,
		ZeroDowntimeDeployments: zeroDowntimeDeploymentsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttributesValue {
	object, diags := NewAttributesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttributesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttributesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttributesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttributesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttributesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttributesValueMust(AttributesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AttributesType) ValueType(ctx context.Context) attr.Value {
	return AttributesValue{}
}

var _ basetypes.ObjectValuable = AttributesValue{}

type AttributesValue struct {
	Aliases                 basetypes.ListValue   `tfsdk:"aliases"`
	AppType                 basetypes.StringValue `tfsdk:"app_type"`
	CreatedAt               basetypes.StringValue `tfsdk:"created_at"`
	Database                basetypes.StringValue `tfsdk:"database"`
	DeploymentScript        basetypes.StringValue `tfsdk:"deployment_script"`
	DeploymentStatus        basetypes.StringValue `tfsdk:"deployment_status"`
	DeploymentUrl           basetypes.StringValue `tfsdk:"deployment_url"`
	HealthcheckUrl          basetypes.StringValue `tfsdk:"healthcheck_url"`
	Https                   basetypes.BoolValue   `tfsdk:"https"`
	Isolated                basetypes.BoolValue   `tfsdk:"isolated"`
	MaintenanceMode         basetypes.ObjectValue `tfsdk:"maintenance_mode"`
	Name                    basetypes.StringValue `tfsdk:"name"`
	PhpVersion              basetypes.StringValue `tfsdk:"php_version"`
	QuickDeploy             basetypes.BoolValue   `tfsdk:"quick_deploy"`
	Repository              basetypes.ObjectValue `tfsdk:"repository"`
	RootDirectory           basetypes.StringValue `tfsdk:"root_directory"`
	SharedPaths             basetypes.MapValue    `tfsdk:"shared_paths"`
	Status                  basetypes.StringValue `tfsdk:"status"`
	UpdatedAt               basetypes.StringValue `tfsdk:"updated_at"`
	Url                     basetypes.StringValue `tfsdk:"url"`
	User                    basetypes.StringValue `tfsdk:"user"`
	UsesEnvoyer             basetypes.BoolValue   `tfsdk:"uses_envoyer"`
	WebDirectory            basetypes.StringValue `tfsdk:"web_directory"`
	Wildcards               basetypes.BoolValue   `tfsdk:"wildcards"`
	ZeroDowntimeDeployments basetypes.BoolValue   `tfsdk:"zero_downtime_deployments"`
	state                   attr.ValueState
}

func (v AttributesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 25)

	var val tftypes.Value
	var err error

	attrTypes["aliases"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["app_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["database"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["deployment_script"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["deployment_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["deployment_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["healthcheck_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["https"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["isolated"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["maintenance_mode"] = basetypes.ObjectType{
		AttrTypes: MaintenanceModeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["php_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["quick_deploy"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["repository"] = basetypes.ObjectType{
		AttrTypes: RepositoryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["root_directory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["shared_paths"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uses_envoyer"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["web_directory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wildcards"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["zero_downtime_deployments"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 25)

		val, err = v.Aliases.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aliases"] = val

		val, err = v.AppType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_type"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Database.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database"] = val

		val, err = v.DeploymentScript.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deployment_script"] = val

		val, err = v.DeploymentStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deployment_status"] = val

		val, err = v.DeploymentUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deployment_url"] = val

		val, err = v.HealthcheckUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["healthcheck_url"] = val

		val, err = v.Https.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["https"] = val

		val, err = v.Isolated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["isolated"] = val

		val, err = v.MaintenanceMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maintenance_mode"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PhpVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["php_version"] = val

		val, err = v.QuickDeploy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quick_deploy"] = val

		val, err = v.Repository.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["repository"] = val

		val, err = v.RootDirectory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["root_directory"] = val

		val, err = v.SharedPaths.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["shared_paths"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		val, err = v.UsesEnvoyer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uses_envoyer"] = val

		val, err = v.WebDirectory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["web_directory"] = val

		val, err = v.Wildcards.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wildcards"] = val

		val, err = v.ZeroDowntimeDeployments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["zero_downtime_deployments"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttributesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttributesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttributesValue) String() string {
	return "AttributesValue"
}

func (v AttributesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var maintenanceMode basetypes.ObjectValue

	if v.MaintenanceMode.IsNull() {
		maintenanceMode = types.ObjectNull(
			MaintenanceModeValue{}.AttributeTypes(ctx),
		)
	}

	if v.MaintenanceMode.IsUnknown() {
		maintenanceMode = types.ObjectUnknown(
			MaintenanceModeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MaintenanceMode.IsNull() && !v.MaintenanceMode.IsUnknown() {
		maintenanceMode = types.ObjectValueMust(
			MaintenanceModeValue{}.AttributeTypes(ctx),
			v.MaintenanceMode.Attributes(),
		)
	}

	var repository basetypes.ObjectValue

	if v.Repository.IsNull() {
		repository = types.ObjectNull(
			RepositoryValue{}.AttributeTypes(ctx),
		)
	}

	if v.Repository.IsUnknown() {
		repository = types.ObjectUnknown(
			RepositoryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Repository.IsNull() && !v.Repository.IsUnknown() {
		repository = types.ObjectValueMust(
			RepositoryValue{}.AttributeTypes(ctx),
			v.Repository.Attributes(),
		)
	}

	var aliasesVal basetypes.ListValue
	switch {
	case v.Aliases.IsUnknown():
		aliasesVal = types.ListUnknown(types.StringType)
	case v.Aliases.IsNull():
		aliasesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		aliasesVal, d = types.ListValue(types.StringType, v.Aliases.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"aliases": basetypes.ListType{
				ElemType: types.StringType,
			},
			"app_type":          basetypes.StringType{},
			"created_at":        basetypes.StringType{},
			"database":          basetypes.StringType{},
			"deployment_script": basetypes.StringType{},
			"deployment_status": basetypes.StringType{},
			"deployment_url":    basetypes.StringType{},
			"healthcheck_url":   basetypes.StringType{},
			"https":             basetypes.BoolType{},
			"isolated":          basetypes.BoolType{},
			"maintenance_mode": basetypes.ObjectType{
				AttrTypes: MaintenanceModeValue{}.AttributeTypes(ctx),
			},
			"name":         basetypes.StringType{},
			"php_version":  basetypes.StringType{},
			"quick_deploy": basetypes.BoolType{},
			"repository": basetypes.ObjectType{
				AttrTypes: RepositoryValue{}.AttributeTypes(ctx),
			},
			"root_directory": basetypes.StringType{},
			"shared_paths": basetypes.MapType{
				ElemType: types.StringType,
			},
			"status":                    basetypes.StringType{},
			"updated_at":                basetypes.StringType{},
			"url":                       basetypes.StringType{},
			"user":                      basetypes.StringType{},
			"uses_envoyer":              basetypes.BoolType{},
			"web_directory":             basetypes.StringType{},
			"wildcards":                 basetypes.BoolType{},
			"zero_downtime_deployments": basetypes.BoolType{},
		}), diags
	}

	var sharedPathsVal basetypes.MapValue
	switch {
	case v.SharedPaths.IsUnknown():
		sharedPathsVal = types.MapUnknown(types.StringType)
	case v.SharedPaths.IsNull():
		sharedPathsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		sharedPathsVal, d = types.MapValue(types.StringType, v.SharedPaths.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"aliases": basetypes.ListType{
				ElemType: types.StringType,
			},
			"app_type":          basetypes.StringType{},
			"created_at":        basetypes.StringType{},
			"database":          basetypes.StringType{},
			"deployment_script": basetypes.StringType{},
			"deployment_status": basetypes.StringType{},
			"deployment_url":    basetypes.StringType{},
			"healthcheck_url":   basetypes.StringType{},
			"https":             basetypes.BoolType{},
			"isolated":          basetypes.BoolType{},
			"maintenance_mode": basetypes.ObjectType{
				AttrTypes: MaintenanceModeValue{}.AttributeTypes(ctx),
			},
			"name":         basetypes.StringType{},
			"php_version":  basetypes.StringType{},
			"quick_deploy": basetypes.BoolType{},
			"repository": basetypes.ObjectType{
				AttrTypes: RepositoryValue{}.AttributeTypes(ctx),
			},
			"root_directory": basetypes.StringType{},
			"shared_paths": basetypes.MapType{
				ElemType: types.StringType,
			},
			"status":                    basetypes.StringType{},
			"updated_at":                basetypes.StringType{},
			"url":                       basetypes.StringType{},
			"user":                      basetypes.StringType{},
			"uses_envoyer":              basetypes.BoolType{},
			"web_directory":             basetypes.StringType{},
			"wildcards":                 basetypes.BoolType{},
			"zero_downtime_deployments": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"aliases": basetypes.ListType{
			ElemType: types.StringType,
		},
		"app_type":          basetypes.StringType{},
		"created_at":        basetypes.StringType{},
		"database":          basetypes.StringType{},
		"deployment_script": basetypes.StringType{},
		"deployment_status": basetypes.StringType{},
		"deployment_url":    basetypes.StringType{},
		"healthcheck_url":   basetypes.StringType{},
		"https":             basetypes.BoolType{},
		"isolated":          basetypes.BoolType{},
		"maintenance_mode": basetypes.ObjectType{
			AttrTypes: MaintenanceModeValue{}.AttributeTypes(ctx),
		},
		"name":         basetypes.StringType{},
		"php_version":  basetypes.StringType{},
		"quick_deploy": basetypes.BoolType{},
		"repository": basetypes.ObjectType{
			AttrTypes: RepositoryValue{}.AttributeTypes(ctx),
		},
		"root_directory": basetypes.StringType{},
		"shared_paths": basetypes.MapType{
			ElemType: types.StringType,
		},
		"status":                    basetypes.StringType{},
		"updated_at":                basetypes.StringType{},
		"url":                       basetypes.StringType{},
		"user":                      basetypes.StringType{},
		"uses_envoyer":              basetypes.BoolType{},
		"web_directory":             basetypes.StringType{},
		"wildcards":                 basetypes.BoolType{},
		"zero_downtime_deployments": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aliases":                   aliasesVal,
			"app_type":                  v.AppType,
			"created_at":                v.CreatedAt,
			"database":                  v.Database,
			"deployment_script":         v.DeploymentScript,
			"deployment_status":         v.DeploymentStatus,
			"deployment_url":            v.DeploymentUrl,
			"healthcheck_url":           v.HealthcheckUrl,
			"https":                     v.Https,
			"isolated":                  v.Isolated,
			"maintenance_mode":          maintenanceMode,
			"name":                      v.Name,
			"php_version":               v.PhpVersion,
			"quick_deploy":              v.QuickDeploy,
			"repository":                repository,
			"root_directory":            v.RootDirectory,
			"shared_paths":              sharedPathsVal,
			"status":                    v.Status,
			"updated_at":                v.UpdatedAt,
			"url":                       v.Url,
			"user":                      v.User,
			"uses_envoyer":              v.UsesEnvoyer,
			"web_directory":             v.WebDirectory,
			"wildcards":                 v.Wildcards,
			"zero_downtime_deployments": v.ZeroDowntimeDeployments,
		})

	return objVal, diags
}

func (v AttributesValue) Equal(o attr.Value) bool {
	other, ok := o.(AttributesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Aliases.Equal(other.Aliases) {
		return false
	}

	if !v.AppType.Equal(other.AppType) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Database.Equal(other.Database) {
		return false
	}

	if !v.DeploymentScript.Equal(other.DeploymentScript) {
		return false
	}

	if !v.DeploymentStatus.Equal(other.DeploymentStatus) {
		return false
	}

	if !v.DeploymentUrl.Equal(other.DeploymentUrl) {
		return false
	}

	if !v.HealthcheckUrl.Equal(other.HealthcheckUrl) {
		return false
	}

	if !v.Https.Equal(other.Https) {
		return false
	}

	if !v.Isolated.Equal(other.Isolated) {
		return false
	}

	if !v.MaintenanceMode.Equal(other.MaintenanceMode) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PhpVersion.Equal(other.PhpVersion) {
		return false
	}

	if !v.QuickDeploy.Equal(other.QuickDeploy) {
		return false
	}

	if !v.Repository.Equal(other.Repository) {
		return false
	}

	if !v.RootDirectory.Equal(other.RootDirectory) {
		return false
	}

	if !v.SharedPaths.Equal(other.SharedPaths) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.User.Equal(other.User) {
		return false
	}

	if !v.UsesEnvoyer.Equal(other.UsesEnvoyer) {
		return false
	}

	if !v.WebDirectory.Equal(other.WebDirectory) {
		return false
	}

	if !v.Wildcards.Equal(other.Wildcards) {
		return false
	}

	if !v.ZeroDowntimeDeployments.Equal(other.ZeroDowntimeDeployments) {
		return false
	}

	return true
}

func (v AttributesValue) Type(ctx context.Context) attr.Type {
	return AttributesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttributesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aliases": basetypes.ListType{
			ElemType: types.StringType,
		},
		"app_type":          basetypes.StringType{},
		"created_at":        basetypes.StringType{},
		"database":          basetypes.StringType{},
		"deployment_script": basetypes.StringType{},
		"deployment_status": basetypes.StringType{},
		"deployment_url":    basetypes.StringType{},
		"healthcheck_url":   basetypes.StringType{},
		"https":             basetypes.BoolType{},
		"isolated":          basetypes.BoolType{},
		"maintenance_mode": basetypes.ObjectType{
			AttrTypes: MaintenanceModeValue{}.AttributeTypes(ctx),
		},
		"name":         basetypes.StringType{},
		"php_version":  basetypes.StringType{},
		"quick_deploy": basetypes.BoolType{},
		"repository": basetypes.ObjectType{
			AttrTypes: RepositoryValue{}.AttributeTypes(ctx),
		},
		"root_directory": basetypes.StringType{},
		"shared_paths": basetypes.MapType{
			ElemType: types.StringType,
		},
		"status":                    basetypes.StringType{},
		"updated_at":                basetypes.StringType{},
		"url":                       basetypes.StringType{},
		"user":                      basetypes.StringType{},
		"uses_envoyer":              basetypes.BoolType{},
		"web_directory":             basetypes.StringType{},
		"wildcards":                 basetypes.BoolType{},
		"zero_downtime_deployments": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MaintenanceModeType{}

type MaintenanceModeType struct {
	basetypes.ObjectType
}

func (t MaintenanceModeType) Equal(o attr.Type) bool {
	other, ok := o.(MaintenanceModeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MaintenanceModeType) String() string {
	return "MaintenanceModeType"
}

func (t MaintenanceModeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MaintenanceModeValue{
		Enabled: enabledVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMaintenanceModeValueNull() MaintenanceModeValue {
	return MaintenanceModeValue{
		state: attr.ValueStateNull,
	}
}

func NewMaintenanceModeValueUnknown() MaintenanceModeValue {
	return MaintenanceModeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMaintenanceModeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MaintenanceModeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MaintenanceModeValue Attribute Value",
				"While creating a MaintenanceModeValue value, a missing attribute value was detected. "+
					"A MaintenanceModeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MaintenanceModeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MaintenanceModeValue Attribute Type",
				"While creating a MaintenanceModeValue value, an invalid attribute value was detected. "+
					"A MaintenanceModeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MaintenanceModeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MaintenanceModeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MaintenanceModeValue Attribute Value",
				"While creating a MaintenanceModeValue value, an extra attribute value was detected. "+
					"A MaintenanceModeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MaintenanceModeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMaintenanceModeValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMaintenanceModeValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewMaintenanceModeValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewMaintenanceModeValueUnknown(), diags
	}

	return MaintenanceModeValue{
		Enabled: enabledVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMaintenanceModeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MaintenanceModeValue {
	object, diags := NewMaintenanceModeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMaintenanceModeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MaintenanceModeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMaintenanceModeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMaintenanceModeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMaintenanceModeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMaintenanceModeValueMust(MaintenanceModeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MaintenanceModeType) ValueType(ctx context.Context) attr.Value {
	return MaintenanceModeValue{}
}

var _ basetypes.ObjectValuable = MaintenanceModeValue{}

type MaintenanceModeValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Status  basetypes.StringValue `tfsdk:"status"`
	state   attr.ValueState
}

func (v MaintenanceModeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MaintenanceModeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MaintenanceModeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MaintenanceModeValue) String() string {
	return "MaintenanceModeValue"
}

func (v MaintenanceModeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"status":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"status":  v.Status,
		})

	return objVal, diags
}

func (v MaintenanceModeValue) Equal(o attr.Value) bool {
	other, ok := o.(MaintenanceModeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v MaintenanceModeValue) Type(ctx context.Context) attr.Type {
	return MaintenanceModeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MaintenanceModeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"status":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RepositoryType{}

type RepositoryType struct {
	basetypes.ObjectType
}

func (t RepositoryType) Equal(o attr.Type) bool {
	other, ok := o.(RepositoryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RepositoryType) String() string {
	return "RepositoryType"
}

func (t RepositoryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	branchAttribute, ok := attributes["branch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`branch is missing from object`)

		return nil, diags
	}

	branchVal, ok := branchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`branch expected to be basetypes.StringValue, was: %T`, branchAttribute))
	}

	providerAttribute, ok := attributes["provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider is missing from object`)

		return nil, diags
	}

	providerVal, ok := providerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider expected to be basetypes.StringValue, was: %T`, providerAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RepositoryValue{
		Branch:   branchVal,
		Provider: providerVal,
		Status:   statusVal,
		Url:      urlVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewRepositoryValueNull() RepositoryValue {
	return RepositoryValue{
		state: attr.ValueStateNull,
	}
}

func NewRepositoryValueUnknown() RepositoryValue {
	return RepositoryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRepositoryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RepositoryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RepositoryValue Attribute Value",
				"While creating a RepositoryValue value, a missing attribute value was detected. "+
					"A RepositoryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RepositoryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RepositoryValue Attribute Type",
				"While creating a RepositoryValue value, an invalid attribute value was detected. "+
					"A RepositoryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RepositoryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RepositoryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RepositoryValue Attribute Value",
				"While creating a RepositoryValue value, an extra attribute value was detected. "+
					"A RepositoryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RepositoryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRepositoryValueUnknown(), diags
	}

	branchAttribute, ok := attributes["branch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`branch is missing from object`)

		return NewRepositoryValueUnknown(), diags
	}

	branchVal, ok := branchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`branch expected to be basetypes.StringValue, was: %T`, branchAttribute))
	}

	providerAttribute, ok := attributes["provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider is missing from object`)

		return NewRepositoryValueUnknown(), diags
	}

	providerVal, ok := providerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider expected to be basetypes.StringValue, was: %T`, providerAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewRepositoryValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewRepositoryValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewRepositoryValueUnknown(), diags
	}

	return RepositoryValue{
		Branch:   branchVal,
		Provider: providerVal,
		Status:   statusVal,
		Url:      urlVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewRepositoryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RepositoryValue {
	object, diags := NewRepositoryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRepositoryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RepositoryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRepositoryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRepositoryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRepositoryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRepositoryValueMust(RepositoryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RepositoryType) ValueType(ctx context.Context) attr.Value {
	return RepositoryValue{}
}

var _ basetypes.ObjectValuable = RepositoryValue{}

type RepositoryValue struct {
	Branch   basetypes.StringValue `tfsdk:"branch"`
	Provider basetypes.StringValue `tfsdk:"provider"`
	Status   basetypes.StringValue `tfsdk:"status"`
	Url      basetypes.StringValue `tfsdk:"url"`
	state    attr.ValueState
}

func (v RepositoryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["branch"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Branch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["branch"] = val

		val, err = v.Provider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RepositoryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RepositoryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RepositoryValue) String() string {
	return "RepositoryValue"
}

func (v RepositoryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"branch":   basetypes.StringType{},
		"provider": basetypes.StringType{},
		"status":   basetypes.StringType{},
		"url":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"branch":   v.Branch,
			"provider": v.Provider,
			"status":   v.Status,
			"url":      v.Url,
		})

	return objVal, diags
}

func (v RepositoryValue) Equal(o attr.Value) bool {
	other, ok := o.(RepositoryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Branch.Equal(other.Branch) {
		return false
	}

	if !v.Provider.Equal(other.Provider) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v RepositoryValue) Type(ctx context.Context) attr.Type {
	return RepositoryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RepositoryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"branch":   basetypes.StringType{},
		"provider": basetypes.StringType{},
		"status":   basetypes.StringType{},
		"url":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LinksType{}

type LinksType struct {
	basetypes.ObjectType
}

func (t LinksType) Equal(o attr.Type) bool {
	other, ok := o.(LinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinksType) String() string {
	return "LinksType"
}

func (t LinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return nil, diags
	}

	selfVal, ok := selfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.ObjectValue, was: %T`, selfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinksValue{
		Self:  selfVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLinksValueNull() LinksValue {
	return LinksValue{
		state: attr.ValueStateNull,
	}
}

func NewLinksValueUnknown() LinksValue {
	return LinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinksValue Attribute Value",
				"While creating a LinksValue value, a missing attribute value was detected. "+
					"A LinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinksValue Attribute Type",
				"While creating a LinksValue value, an invalid attribute value was detected. "+
					"A LinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinksValue Attribute Value",
				"While creating a LinksValue value, an extra attribute value was detected. "+
					"A LinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	selfVal, ok := selfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.ObjectValue, was: %T`, selfAttribute))
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	return LinksValue{
		Self:  selfVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinksValue {
	object, diags := NewLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinksValueMust(LinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinksType) ValueType(ctx context.Context) attr.Value {
	return LinksValue{}
}

var _ basetypes.ObjectValuable = LinksValue{}

type LinksValue struct {
	Self  basetypes.ObjectValue `tfsdk:"self"`
	state attr.ValueState
}

func (v LinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["self"] = basetypes.ObjectType{
		AttrTypes: SelfValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Self.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["self"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinksValue) String() string {
	return "LinksValue"
}

func (v LinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var self basetypes.ObjectValue

	if v.Self.IsNull() {
		self = types.ObjectNull(
			SelfValue{}.AttributeTypes(ctx),
		)
	}

	if v.Self.IsUnknown() {
		self = types.ObjectUnknown(
			SelfValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Self.IsNull() && !v.Self.IsUnknown() {
		self = types.ObjectValueMust(
			SelfValue{}.AttributeTypes(ctx),
			v.Self.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"self": basetypes.ObjectType{
			AttrTypes: SelfValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"self": self,
		})

	return objVal, diags
}

func (v LinksValue) Equal(o attr.Value) bool {
	other, ok := o.(LinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Self.Equal(other.Self) {
		return false
	}

	return true
}

func (v LinksValue) Type(ctx context.Context) attr.Type {
	return LinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"self": basetypes.ObjectType{
			AttrTypes: SelfValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SelfType{}

type SelfType struct {
	basetypes.ObjectType
}

func (t SelfType) Equal(o attr.Type) bool {
	other, ok := o.(SelfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SelfType) String() string {
	return "SelfType"
}

func (t SelfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	describedbyAttribute, ok := attributes["describedby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`describedby is missing from object`)

		return nil, diags
	}

	describedbyVal, ok := describedbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`describedby expected to be basetypes.StringValue, was: %T`, describedbyAttribute))
	}

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return nil, diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	hreflangAttribute, ok := attributes["hreflang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hreflang is missing from object`)

		return nil, diags
	}

	hreflangVal, ok := hreflangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hreflang expected to be basetypes.StringValue, was: %T`, hreflangAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return nil, diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return nil, diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return nil, diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SelfValue{
		Describedby: describedbyVal,
		Href:        hrefVal,
		Hreflang:    hreflangVal,
		Meta:        metaVal,
		Rel:         relVal,
		Title:       titleVal,
		SelfType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSelfValueNull() SelfValue {
	return SelfValue{
		state: attr.ValueStateNull,
	}
}

func NewSelfValueUnknown() SelfValue {
	return SelfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSelfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SelfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SelfValue Attribute Value",
				"While creating a SelfValue value, a missing attribute value was detected. "+
					"A SelfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SelfValue Attribute Type",
				"While creating a SelfValue value, an invalid attribute value was detected. "+
					"A SelfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SelfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SelfValue Attribute Value",
				"While creating a SelfValue value, an extra attribute value was detected. "+
					"A SelfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SelfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSelfValueUnknown(), diags
	}

	describedbyAttribute, ok := attributes["describedby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`describedby is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	describedbyVal, ok := describedbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`describedby expected to be basetypes.StringValue, was: %T`, describedbyAttribute))
	}

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	hreflangAttribute, ok := attributes["hreflang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hreflang is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	hreflangVal, ok := hreflangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hreflang expected to be basetypes.StringValue, was: %T`, hreflangAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSelfValueUnknown(), diags
	}

	return SelfValue{
		Describedby: describedbyVal,
		Href:        hrefVal,
		Hreflang:    hreflangVal,
		Meta:        metaVal,
		Rel:         relVal,
		Title:       titleVal,
		SelfType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSelfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SelfValue {
	object, diags := NewSelfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSelfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SelfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSelfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSelfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSelfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSelfValueMust(SelfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SelfType) ValueType(ctx context.Context) attr.Value {
	return SelfValue{}
}

var _ basetypes.ObjectValuable = SelfValue{}

type SelfValue struct {
	Describedby basetypes.StringValue `tfsdk:"describedby"`
	Href        basetypes.StringValue `tfsdk:"href"`
	Hreflang    basetypes.StringValue `tfsdk:"hreflang"`
	Meta        basetypes.ObjectValue `tfsdk:"meta"`
	Rel         basetypes.StringValue `tfsdk:"rel"`
	Title       basetypes.StringValue `tfsdk:"title"`
	SelfType    basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v SelfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["describedby"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["href"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hreflang"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["meta"] = basetypes.ObjectType{
		AttrTypes: MetaValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["rel"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["title"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Describedby.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["describedby"] = val

		val, err = v.Href.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["href"] = val

		val, err = v.Hreflang.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hreflang"] = val

		val, err = v.Meta.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["meta"] = val

		val, err = v.Rel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rel"] = val

		val, err = v.Title.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["title"] = val

		val, err = v.SelfType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SelfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SelfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SelfValue) String() string {
	return "SelfValue"
}

func (v SelfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var meta basetypes.ObjectValue

	if v.Meta.IsNull() {
		meta = types.ObjectNull(
			MetaValue{}.AttributeTypes(ctx),
		)
	}

	if v.Meta.IsUnknown() {
		meta = types.ObjectUnknown(
			MetaValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Meta.IsNull() && !v.Meta.IsUnknown() {
		meta = types.ObjectValueMust(
			MetaValue{}.AttributeTypes(ctx),
			v.Meta.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"describedby": basetypes.StringType{},
		"href":        basetypes.StringType{},
		"hreflang":    basetypes.StringType{},
		"meta": basetypes.ObjectType{
			AttrTypes: MetaValue{}.AttributeTypes(ctx),
		},
		"rel":   basetypes.StringType{},
		"title": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"describedby": v.Describedby,
			"href":        v.Href,
			"hreflang":    v.Hreflang,
			"meta":        meta,
			"rel":         v.Rel,
			"title":       v.Title,
			"type":        v.SelfType,
		})

	return objVal, diags
}

func (v SelfValue) Equal(o attr.Value) bool {
	other, ok := o.(SelfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Describedby.Equal(other.Describedby) {
		return false
	}

	if !v.Href.Equal(other.Href) {
		return false
	}

	if !v.Hreflang.Equal(other.Hreflang) {
		return false
	}

	if !v.Meta.Equal(other.Meta) {
		return false
	}

	if !v.Rel.Equal(other.Rel) {
		return false
	}

	if !v.Title.Equal(other.Title) {
		return false
	}

	if !v.SelfType.Equal(other.SelfType) {
		return false
	}

	return true
}

func (v SelfValue) Type(ctx context.Context) attr.Type {
	return SelfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SelfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"describedby": basetypes.StringType{},
		"href":        basetypes.StringType{},
		"hreflang":    basetypes.StringType{},
		"meta": basetypes.ObjectType{
			AttrTypes: MetaValue{}.AttributeTypes(ctx),
		},
		"rel":   basetypes.StringType{},
		"title": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MetaType{}

type MetaType struct {
	basetypes.ObjectType
}

func (t MetaType) Equal(o attr.Type) bool {
	other, ok := o.(MetaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetaType) String() string {
	return "MetaType"
}

func (t MetaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return MetaValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewMetaValueNull() MetaValue {
	return MetaValue{
		state: attr.ValueStateNull,
	}
}

func NewMetaValueUnknown() MetaValue {
	return MetaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetaValue Attribute Value",
				"While creating a MetaValue value, a missing attribute value was detected. "+
					"A MetaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetaValue Attribute Type",
				"While creating a MetaValue value, an invalid attribute value was detected. "+
					"A MetaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetaValue Attribute Value",
				"While creating a MetaValue value, an extra attribute value was detected. "+
					"A MetaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	return MetaValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewMetaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetaValue {
	object, diags := NewMetaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetaValueMust(MetaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetaType) ValueType(ctx context.Context) attr.Value {
	return MetaValue{}
}

var _ basetypes.ObjectValuable = MetaValue{}

type MetaValue struct {
	state attr.ValueState
}

func (v MetaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetaValue) String() string {
	return "MetaValue"
}

func (v MetaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v MetaValue) Equal(o attr.Value) bool {
	other, ok := o.(MetaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v MetaValue) Type(ctx context.Context) attr.Type {
	return MetaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = RelationshipsType{}

type RelationshipsType struct {
	basetypes.ObjectType
}

func (t RelationshipsType) Equal(o attr.Type) bool {
	other, ok := o.(RelationshipsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RelationshipsType) String() string {
	return "RelationshipsType"
}

func (t RelationshipsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	latestDeploymentAttribute, ok := attributes["latest_deployment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latest_deployment is missing from object`)

		return nil, diags
	}

	latestDeploymentVal, ok := latestDeploymentAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latest_deployment expected to be basetypes.ObjectValue, was: %T`, latestDeploymentAttribute))
	}

	redirectRulesAttribute, ok := attributes["redirect_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redirect_rules is missing from object`)

		return nil, diags
	}

	redirectRulesVal, ok := redirectRulesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redirect_rules expected to be basetypes.ObjectValue, was: %T`, redirectRulesAttribute))
	}

	securityRulesAttribute, ok := attributes["security_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_rules is missing from object`)

		return nil, diags
	}

	securityRulesVal, ok := securityRulesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_rules expected to be basetypes.ObjectValue, was: %T`, securityRulesAttribute))
	}

	serverAttribute, ok := attributes["server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server is missing from object`)

		return nil, diags
	}

	serverVal, ok := serverAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server expected to be basetypes.ObjectValue, was: %T`, serverAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ObjectValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RelationshipsValue{
		LatestDeployment: latestDeploymentVal,
		RedirectRules:    redirectRulesVal,
		SecurityRules:    securityRulesVal,
		Server:           serverVal,
		Tags:             tagsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRelationshipsValueNull() RelationshipsValue {
	return RelationshipsValue{
		state: attr.ValueStateNull,
	}
}

func NewRelationshipsValueUnknown() RelationshipsValue {
	return RelationshipsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRelationshipsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RelationshipsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RelationshipsValue Attribute Value",
				"While creating a RelationshipsValue value, a missing attribute value was detected. "+
					"A RelationshipsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RelationshipsValue Attribute Type",
				"While creating a RelationshipsValue value, an invalid attribute value was detected. "+
					"A RelationshipsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RelationshipsValue Attribute Value",
				"While creating a RelationshipsValue value, an extra attribute value was detected. "+
					"A RelationshipsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RelationshipsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRelationshipsValueUnknown(), diags
	}

	latestDeploymentAttribute, ok := attributes["latest_deployment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latest_deployment is missing from object`)

		return NewRelationshipsValueUnknown(), diags
	}

	latestDeploymentVal, ok := latestDeploymentAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latest_deployment expected to be basetypes.ObjectValue, was: %T`, latestDeploymentAttribute))
	}

	redirectRulesAttribute, ok := attributes["redirect_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redirect_rules is missing from object`)

		return NewRelationshipsValueUnknown(), diags
	}

	redirectRulesVal, ok := redirectRulesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redirect_rules expected to be basetypes.ObjectValue, was: %T`, redirectRulesAttribute))
	}

	securityRulesAttribute, ok := attributes["security_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_rules is missing from object`)

		return NewRelationshipsValueUnknown(), diags
	}

	securityRulesVal, ok := securityRulesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_rules expected to be basetypes.ObjectValue, was: %T`, securityRulesAttribute))
	}

	serverAttribute, ok := attributes["server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server is missing from object`)

		return NewRelationshipsValueUnknown(), diags
	}

	serverVal, ok := serverAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server expected to be basetypes.ObjectValue, was: %T`, serverAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewRelationshipsValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ObjectValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return NewRelationshipsValueUnknown(), diags
	}

	return RelationshipsValue{
		LatestDeployment: latestDeploymentVal,
		RedirectRules:    redirectRulesVal,
		SecurityRules:    securityRulesVal,
		Server:           serverVal,
		Tags:             tagsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRelationshipsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RelationshipsValue {
	object, diags := NewRelationshipsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRelationshipsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RelationshipsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRelationshipsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRelationshipsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRelationshipsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRelationshipsValueMust(RelationshipsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RelationshipsType) ValueType(ctx context.Context) attr.Value {
	return RelationshipsValue{}
}

var _ basetypes.ObjectValuable = RelationshipsValue{}

type RelationshipsValue struct {
	LatestDeployment basetypes.ObjectValue `tfsdk:"latest_deployment"`
	RedirectRules    basetypes.ObjectValue `tfsdk:"redirect_rules"`
	SecurityRules    basetypes.ObjectValue `tfsdk:"security_rules"`
	Server           basetypes.ObjectValue `tfsdk:"server"`
	Tags             basetypes.ObjectValue `tfsdk:"tags"`
	state            attr.ValueState
}

func (v RelationshipsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["latest_deployment"] = basetypes.ObjectType{
		AttrTypes: LatestDeploymentValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["redirect_rules"] = basetypes.ObjectType{
		AttrTypes: RedirectRulesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["security_rules"] = basetypes.ObjectType{
		AttrTypes: SecurityRulesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["server"] = basetypes.ObjectType{
		AttrTypes: ServerValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ObjectType{
		AttrTypes: TagsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.LatestDeployment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latest_deployment"] = val

		val, err = v.RedirectRules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redirect_rules"] = val

		val, err = v.SecurityRules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_rules"] = val

		val, err = v.Server.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RelationshipsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RelationshipsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RelationshipsValue) String() string {
	return "RelationshipsValue"
}

func (v RelationshipsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var latestDeployment basetypes.ObjectValue

	if v.LatestDeployment.IsNull() {
		latestDeployment = types.ObjectNull(
			LatestDeploymentValue{}.AttributeTypes(ctx),
		)
	}

	if v.LatestDeployment.IsUnknown() {
		latestDeployment = types.ObjectUnknown(
			LatestDeploymentValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LatestDeployment.IsNull() && !v.LatestDeployment.IsUnknown() {
		latestDeployment = types.ObjectValueMust(
			LatestDeploymentValue{}.AttributeTypes(ctx),
			v.LatestDeployment.Attributes(),
		)
	}

	var redirectRules basetypes.ObjectValue

	if v.RedirectRules.IsNull() {
		redirectRules = types.ObjectNull(
			RedirectRulesValue{}.AttributeTypes(ctx),
		)
	}

	if v.RedirectRules.IsUnknown() {
		redirectRules = types.ObjectUnknown(
			RedirectRulesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RedirectRules.IsNull() && !v.RedirectRules.IsUnknown() {
		redirectRules = types.ObjectValueMust(
			RedirectRulesValue{}.AttributeTypes(ctx),
			v.RedirectRules.Attributes(),
		)
	}

	var securityRules basetypes.ObjectValue

	if v.SecurityRules.IsNull() {
		securityRules = types.ObjectNull(
			SecurityRulesValue{}.AttributeTypes(ctx),
		)
	}

	if v.SecurityRules.IsUnknown() {
		securityRules = types.ObjectUnknown(
			SecurityRulesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SecurityRules.IsNull() && !v.SecurityRules.IsUnknown() {
		securityRules = types.ObjectValueMust(
			SecurityRulesValue{}.AttributeTypes(ctx),
			v.SecurityRules.Attributes(),
		)
	}

	var server basetypes.ObjectValue

	if v.Server.IsNull() {
		server = types.ObjectNull(
			ServerValue{}.AttributeTypes(ctx),
		)
	}

	if v.Server.IsUnknown() {
		server = types.ObjectUnknown(
			ServerValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Server.IsNull() && !v.Server.IsUnknown() {
		server = types.ObjectValueMust(
			ServerValue{}.AttributeTypes(ctx),
			v.Server.Attributes(),
		)
	}

	var tags basetypes.ObjectValue

	if v.Tags.IsNull() {
		tags = types.ObjectNull(
			TagsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Tags.IsUnknown() {
		tags = types.ObjectUnknown(
			TagsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Tags.IsNull() && !v.Tags.IsUnknown() {
		tags = types.ObjectValueMust(
			TagsValue{}.AttributeTypes(ctx),
			v.Tags.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"latest_deployment": basetypes.ObjectType{
			AttrTypes: LatestDeploymentValue{}.AttributeTypes(ctx),
		},
		"redirect_rules": basetypes.ObjectType{
			AttrTypes: RedirectRulesValue{}.AttributeTypes(ctx),
		},
		"security_rules": basetypes.ObjectType{
			AttrTypes: SecurityRulesValue{}.AttributeTypes(ctx),
		},
		"server": basetypes.ObjectType{
			AttrTypes: ServerValue{}.AttributeTypes(ctx),
		},
		"tags": basetypes.ObjectType{
			AttrTypes: TagsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"latest_deployment": latestDeployment,
			"redirect_rules":    redirectRules,
			"security_rules":    securityRules,
			"server":            server,
			"tags":              tags,
		})

	return objVal, diags
}

func (v RelationshipsValue) Equal(o attr.Value) bool {
	other, ok := o.(RelationshipsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LatestDeployment.Equal(other.LatestDeployment) {
		return false
	}

	if !v.RedirectRules.Equal(other.RedirectRules) {
		return false
	}

	if !v.SecurityRules.Equal(other.SecurityRules) {
		return false
	}

	if !v.Server.Equal(other.Server) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	return true
}

func (v RelationshipsValue) Type(ctx context.Context) attr.Type {
	return RelationshipsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RelationshipsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"latest_deployment": basetypes.ObjectType{
			AttrTypes: LatestDeploymentValue{}.AttributeTypes(ctx),
		},
		"redirect_rules": basetypes.ObjectType{
			AttrTypes: RedirectRulesValue{}.AttributeTypes(ctx),
		},
		"security_rules": basetypes.ObjectType{
			AttrTypes: SecurityRulesValue{}.AttributeTypes(ctx),
		},
		"server": basetypes.ObjectType{
			AttrTypes: ServerValue{}.AttributeTypes(ctx),
		},
		"tags": basetypes.ObjectType{
			AttrTypes: TagsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = LatestDeploymentType{}

type LatestDeploymentType struct {
	basetypes.ObjectType
}

func (t LatestDeploymentType) Equal(o attr.Type) bool {
	other, ok := o.(LatestDeploymentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LatestDeploymentType) String() string {
	return "LatestDeploymentType"
}

func (t LatestDeploymentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return nil, diags
	}

	dataVal, ok := dataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ObjectValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LatestDeploymentValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLatestDeploymentValueNull() LatestDeploymentValue {
	return LatestDeploymentValue{
		state: attr.ValueStateNull,
	}
}

func NewLatestDeploymentValueUnknown() LatestDeploymentValue {
	return LatestDeploymentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLatestDeploymentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LatestDeploymentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LatestDeploymentValue Attribute Value",
				"While creating a LatestDeploymentValue value, a missing attribute value was detected. "+
					"A LatestDeploymentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LatestDeploymentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LatestDeploymentValue Attribute Type",
				"While creating a LatestDeploymentValue value, an invalid attribute value was detected. "+
					"A LatestDeploymentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LatestDeploymentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LatestDeploymentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LatestDeploymentValue Attribute Value",
				"While creating a LatestDeploymentValue value, an extra attribute value was detected. "+
					"A LatestDeploymentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LatestDeploymentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLatestDeploymentValueUnknown(), diags
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return NewLatestDeploymentValueUnknown(), diags
	}

	dataVal, ok := dataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ObjectValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return NewLatestDeploymentValueUnknown(), diags
	}

	return LatestDeploymentValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLatestDeploymentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LatestDeploymentValue {
	object, diags := NewLatestDeploymentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLatestDeploymentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LatestDeploymentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLatestDeploymentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLatestDeploymentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLatestDeploymentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLatestDeploymentValueMust(LatestDeploymentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LatestDeploymentType) ValueType(ctx context.Context) attr.Value {
	return LatestDeploymentValue{}
}

var _ basetypes.ObjectValuable = LatestDeploymentValue{}

type LatestDeploymentValue struct {
	Data  basetypes.ObjectValue `tfsdk:"data"`
	state attr.ValueState
}

func (v LatestDeploymentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["data"] = basetypes.ObjectType{
		AttrTypes: DataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Data.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LatestDeploymentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LatestDeploymentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LatestDeploymentValue) String() string {
	return "LatestDeploymentValue"
}

func (v LatestDeploymentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var data basetypes.ObjectValue

	if v.Data.IsNull() {
		data = types.ObjectNull(
			DataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Data.IsUnknown() {
		data = types.ObjectUnknown(
			DataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Data.IsNull() && !v.Data.IsUnknown() {
		data = types.ObjectValueMust(
			DataValue{}.AttributeTypes(ctx),
			v.Data.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"data": basetypes.ObjectType{
			AttrTypes: DataValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data": data,
		})

	return objVal, diags
}

func (v LatestDeploymentValue) Equal(o attr.Value) bool {
	other, ok := o.(LatestDeploymentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Data.Equal(other.Data) {
		return false
	}

	return true
}

func (v LatestDeploymentValue) Type(ctx context.Context) attr.Type {
	return LatestDeploymentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LatestDeploymentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data": basetypes.ObjectType{
			AttrTypes: DataValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Id       basetypes.StringValue `tfsdk:"id"`
	DataType basetypes.StringValue `tfsdk:"type"`
	state    attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":   v.Id,
			"type": v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RedirectRulesType{}

type RedirectRulesType struct {
	basetypes.ObjectType
}

func (t RedirectRulesType) Equal(o attr.Type) bool {
	other, ok := o.(RedirectRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RedirectRulesType) String() string {
	return "RedirectRulesType"
}

func (t RedirectRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return nil, diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RedirectRulesValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRedirectRulesValueNull() RedirectRulesValue {
	return RedirectRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewRedirectRulesValueUnknown() RedirectRulesValue {
	return RedirectRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRedirectRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RedirectRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RedirectRulesValue Attribute Value",
				"While creating a RedirectRulesValue value, a missing attribute value was detected. "+
					"A RedirectRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RedirectRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RedirectRulesValue Attribute Type",
				"While creating a RedirectRulesValue value, an invalid attribute value was detected. "+
					"A RedirectRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RedirectRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RedirectRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RedirectRulesValue Attribute Value",
				"While creating a RedirectRulesValue value, an extra attribute value was detected. "+
					"A RedirectRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RedirectRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRedirectRulesValueUnknown(), diags
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return NewRedirectRulesValueUnknown(), diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return NewRedirectRulesValueUnknown(), diags
	}

	return RedirectRulesValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRedirectRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RedirectRulesValue {
	object, diags := NewRedirectRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRedirectRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RedirectRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRedirectRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRedirectRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRedirectRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRedirectRulesValueMust(RedirectRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RedirectRulesType) ValueType(ctx context.Context) attr.Value {
	return RedirectRulesValue{}
}

var _ basetypes.ObjectValuable = RedirectRulesValue{}

type RedirectRulesValue struct {
	Data  basetypes.ListValue `tfsdk:"data"`
	state attr.ValueState
}

func (v RedirectRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["data"] = basetypes.ListType{
		ElemType: DataValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Data.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RedirectRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RedirectRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RedirectRulesValue) String() string {
	return "RedirectRulesValue"
}

func (v RedirectRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	data := types.ListValueMust(
		DataType{
			basetypes.ObjectType{
				AttrTypes: DataValue{}.AttributeTypes(ctx),
			},
		},
		v.Data.Elements(),
	)

	if v.Data.IsNull() {
		data = types.ListNull(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Data.IsUnknown() {
		data = types.ListUnknown(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"data": basetypes.ListType{
			ElemType: DataValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data": data,
		})

	return objVal, diags
}

func (v RedirectRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(RedirectRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Data.Equal(other.Data) {
		return false
	}

	return true
}

func (v RedirectRulesValue) Type(ctx context.Context) attr.Type {
	return RedirectRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RedirectRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data": basetypes.ListType{
			ElemType: DataValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Id       basetypes.StringValue `tfsdk:"id"`
	DataType basetypes.StringValue `tfsdk:"type"`
	state    attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":   v.Id,
			"type": v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityRulesType{}

type SecurityRulesType struct {
	basetypes.ObjectType
}

func (t SecurityRulesType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityRulesType) String() string {
	return "SecurityRulesType"
}

func (t SecurityRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return nil, diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityRulesValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSecurityRulesValueNull() SecurityRulesValue {
	return SecurityRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityRulesValueUnknown() SecurityRulesValue {
	return SecurityRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityRulesValue Attribute Value",
				"While creating a SecurityRulesValue value, a missing attribute value was detected. "+
					"A SecurityRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityRulesValue Attribute Type",
				"While creating a SecurityRulesValue value, an invalid attribute value was detected. "+
					"A SecurityRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityRulesValue Attribute Value",
				"While creating a SecurityRulesValue value, an extra attribute value was detected. "+
					"A SecurityRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityRulesValueUnknown(), diags
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return NewSecurityRulesValueUnknown(), diags
	}

	return SecurityRulesValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSecurityRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityRulesValue {
	object, diags := NewSecurityRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityRulesValueMust(SecurityRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityRulesType) ValueType(ctx context.Context) attr.Value {
	return SecurityRulesValue{}
}

var _ basetypes.ObjectValuable = SecurityRulesValue{}

type SecurityRulesValue struct {
	Data  basetypes.ListValue `tfsdk:"data"`
	state attr.ValueState
}

func (v SecurityRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["data"] = basetypes.ListType{
		ElemType: DataValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Data.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityRulesValue) String() string {
	return "SecurityRulesValue"
}

func (v SecurityRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	data := types.ListValueMust(
		DataType{
			basetypes.ObjectType{
				AttrTypes: DataValue{}.AttributeTypes(ctx),
			},
		},
		v.Data.Elements(),
	)

	if v.Data.IsNull() {
		data = types.ListNull(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Data.IsUnknown() {
		data = types.ListUnknown(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"data": basetypes.ListType{
			ElemType: DataValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data": data,
		})

	return objVal, diags
}

func (v SecurityRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Data.Equal(other.Data) {
		return false
	}

	return true
}

func (v SecurityRulesValue) Type(ctx context.Context) attr.Type {
	return SecurityRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data": basetypes.ListType{
			ElemType: DataValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Id       basetypes.StringValue `tfsdk:"id"`
	DataType basetypes.StringValue `tfsdk:"type"`
	state    attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":   v.Id,
			"type": v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ServerType{}

type ServerType struct {
	basetypes.ObjectType
}

func (t ServerType) Equal(o attr.Type) bool {
	other, ok := o.(ServerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServerType) String() string {
	return "ServerType"
}

func (t ServerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return nil, diags
	}

	dataVal, ok := dataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ObjectValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServerValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewServerValueNull() ServerValue {
	return ServerValue{
		state: attr.ValueStateNull,
	}
}

func NewServerValueUnknown() ServerValue {
	return ServerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServerValue Attribute Value",
				"While creating a ServerValue value, a missing attribute value was detected. "+
					"A ServerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServerValue Attribute Type",
				"While creating a ServerValue value, an invalid attribute value was detected. "+
					"A ServerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServerValue Attribute Value",
				"While creating a ServerValue value, an extra attribute value was detected. "+
					"A ServerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServerValueUnknown(), diags
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return NewServerValueUnknown(), diags
	}

	dataVal, ok := dataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ObjectValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return NewServerValueUnknown(), diags
	}

	return ServerValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewServerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServerValue {
	object, diags := NewServerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServerValueMust(ServerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServerType) ValueType(ctx context.Context) attr.Value {
	return ServerValue{}
}

var _ basetypes.ObjectValuable = ServerValue{}

type ServerValue struct {
	Data  basetypes.ObjectValue `tfsdk:"data"`
	state attr.ValueState
}

func (v ServerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["data"] = basetypes.ObjectType{
		AttrTypes: DataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Data.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServerValue) String() string {
	return "ServerValue"
}

func (v ServerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var data basetypes.ObjectValue

	if v.Data.IsNull() {
		data = types.ObjectNull(
			DataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Data.IsUnknown() {
		data = types.ObjectUnknown(
			DataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Data.IsNull() && !v.Data.IsUnknown() {
		data = types.ObjectValueMust(
			DataValue{}.AttributeTypes(ctx),
			v.Data.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"data": basetypes.ObjectType{
			AttrTypes: DataValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data": data,
		})

	return objVal, diags
}

func (v ServerValue) Equal(o attr.Value) bool {
	other, ok := o.(ServerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Data.Equal(other.Data) {
		return false
	}

	return true
}

func (v ServerValue) Type(ctx context.Context) attr.Type {
	return ServerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data": basetypes.ObjectType{
			AttrTypes: DataValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Id       basetypes.StringValue `tfsdk:"id"`
	DataType basetypes.StringValue `tfsdk:"type"`
	state    attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":   v.Id,
			"type": v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TagsType{}

type TagsType struct {
	basetypes.ObjectType
}

func (t TagsType) Equal(o attr.Type) bool {
	other, ok := o.(TagsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TagsType) String() string {
	return "TagsType"
}

func (t TagsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return nil, diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TagsValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTagsValueNull() TagsValue {
	return TagsValue{
		state: attr.ValueStateNull,
	}
}

func NewTagsValueUnknown() TagsValue {
	return TagsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTagsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TagsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TagsValue Attribute Value",
				"While creating a TagsValue value, a missing attribute value was detected. "+
					"A TagsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TagsValue Attribute Type",
				"While creating a TagsValue value, an invalid attribute value was detected. "+
					"A TagsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TagsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TagsValue Attribute Value",
				"While creating a TagsValue value, an extra attribute value was detected. "+
					"A TagsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TagsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return NewTagsValueUnknown(), diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	return TagsValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTagsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TagsValue {
	object, diags := NewTagsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTagsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TagsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTagsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTagsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTagsValueMust(TagsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TagsType) ValueType(ctx context.Context) attr.Value {
	return TagsValue{}
}

var _ basetypes.ObjectValuable = TagsValue{}

type TagsValue struct {
	Data  basetypes.ListValue `tfsdk:"data"`
	state attr.ValueState
}

func (v TagsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["data"] = basetypes.ListType{
		ElemType: DataValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Data.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TagsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TagsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TagsValue) String() string {
	return "TagsValue"
}

func (v TagsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	data := types.ListValueMust(
		DataType{
			basetypes.ObjectType{
				AttrTypes: DataValue{}.AttributeTypes(ctx),
			},
		},
		v.Data.Elements(),
	)

	if v.Data.IsNull() {
		data = types.ListNull(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Data.IsUnknown() {
		data = types.ListUnknown(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"data": basetypes.ListType{
			ElemType: DataValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data": data,
		})

	return objVal, diags
}

func (v TagsValue) Equal(o attr.Value) bool {
	other, ok := o.(TagsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Data.Equal(other.Data) {
		return false
	}

	return true
}

func (v TagsValue) Type(ctx context.Context) attr.Type {
	return TagsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TagsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data": basetypes.ListType{
			ElemType: DataValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Id       basetypes.StringValue `tfsdk:"id"`
	DataType basetypes.StringValue `tfsdk:"type"`
	state    attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":   v.Id,
			"type": v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SharedPathsType{}

type SharedPathsType struct {
	basetypes.ObjectType
}

func (t SharedPathsType) Equal(o attr.Type) bool {
	other, ok := o.(SharedPathsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SharedPathsType) String() string {
	return "SharedPathsType"
}

func (t SharedPathsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fromAttribute, ok := attributes["from"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from is missing from object`)

		return nil, diags
	}

	fromVal, ok := fromAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from expected to be basetypes.StringValue, was: %T`, fromAttribute))
	}

	toAttribute, ok := attributes["to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to is missing from object`)

		return nil, diags
	}

	toVal, ok := toAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to expected to be basetypes.StringValue, was: %T`, toAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SharedPathsValue{
		From:  fromVal,
		To:    toVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSharedPathsValueNull() SharedPathsValue {
	return SharedPathsValue{
		state: attr.ValueStateNull,
	}
}

func NewSharedPathsValueUnknown() SharedPathsValue {
	return SharedPathsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSharedPathsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SharedPathsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SharedPathsValue Attribute Value",
				"While creating a SharedPathsValue value, a missing attribute value was detected. "+
					"A SharedPathsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SharedPathsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SharedPathsValue Attribute Type",
				"While creating a SharedPathsValue value, an invalid attribute value was detected. "+
					"A SharedPathsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SharedPathsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SharedPathsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SharedPathsValue Attribute Value",
				"While creating a SharedPathsValue value, an extra attribute value was detected. "+
					"A SharedPathsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SharedPathsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSharedPathsValueUnknown(), diags
	}

	fromAttribute, ok := attributes["from"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from is missing from object`)

		return NewSharedPathsValueUnknown(), diags
	}

	fromVal, ok := fromAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from expected to be basetypes.StringValue, was: %T`, fromAttribute))
	}

	toAttribute, ok := attributes["to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to is missing from object`)

		return NewSharedPathsValueUnknown(), diags
	}

	toVal, ok := toAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to expected to be basetypes.StringValue, was: %T`, toAttribute))
	}

	if diags.HasError() {
		return NewSharedPathsValueUnknown(), diags
	}

	return SharedPathsValue{
		From:  fromVal,
		To:    toVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSharedPathsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SharedPathsValue {
	object, diags := NewSharedPathsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSharedPathsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SharedPathsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSharedPathsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSharedPathsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSharedPathsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSharedPathsValueMust(SharedPathsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SharedPathsType) ValueType(ctx context.Context) attr.Value {
	return SharedPathsValue{}
}

var _ basetypes.ObjectValuable = SharedPathsValue{}

type SharedPathsValue struct {
	From  basetypes.StringValue `tfsdk:"from"`
	To    basetypes.StringValue `tfsdk:"to"`
	state attr.ValueState
}

func (v SharedPathsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["from"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.From.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from"] = val

		val, err = v.To.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SharedPathsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SharedPathsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SharedPathsValue) String() string {
	return "SharedPathsValue"
}

func (v SharedPathsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"from": basetypes.StringType{},
		"to":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"from": v.From,
			"to":   v.To,
		})

	return objVal, diags
}

func (v SharedPathsValue) Equal(o attr.Value) bool {
	other, ok := o.(SharedPathsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.From.Equal(other.From) {
		return false
	}

	if !v.To.Equal(other.To) {
		return false
	}

	return true
}

func (v SharedPathsValue) Type(ctx context.Context) attr.Type {
	return SharedPathsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SharedPathsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"from": basetypes.StringType{},
		"to":   basetypes.StringType{},
	}
}
