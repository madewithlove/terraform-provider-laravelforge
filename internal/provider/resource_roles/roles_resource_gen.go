// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_roles

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func RolesResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"attributes": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"created_at": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"updated_at": schema.StringAttribute{
								Computed: true,
							},
						},
						CustomType: AttributesType{
							ObjectType: types.ObjectType{
								AttrTypes: AttributesValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"links": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"self": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"describedby": schema.StringAttribute{
										Computed: true,
									},
									"href": schema.StringAttribute{
										Computed: true,
									},
									"hreflang": schema.StringAttribute{
										Computed:            true,
										Description:         "Language of the target link",
										MarkdownDescription: "Language of the target link",
									},
									"meta": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{},
										CustomType: MetaType{
											ObjectType: types.ObjectType{
												AttrTypes: MetaValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"rel": schema.StringAttribute{
										Computed: true,
									},
									"title": schema.StringAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: SelfType{
									ObjectType: types.ObjectType{
										AttrTypes: SelfValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
						},
						CustomType: LinksType{
							ObjectType: types.ObjectType{
								AttrTypes: LinksValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"relationships": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"permissions": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"data": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Computed: true,
												},
												"type": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: DataType{
												ObjectType: types.ObjectType{
													AttrTypes: DataValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
								},
								CustomType: PermissionsType{
									ObjectType: types.ObjectType{
										AttrTypes: PermissionsValue{}.AttributeTypes(ctx),
									},
								},
								Computed: true,
							},
						},
						CustomType: RelationshipsType{
							ObjectType: types.ObjectType{
								AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"type": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(50),
				},
			},
			"organization": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The organization slug",
				MarkdownDescription: "The organization slug",
			},
			"permissions": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"role": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The role ID",
				MarkdownDescription: "The role ID",
			},
		},
	}
}

type RolesModel struct {
	Data         DataValue    `tfsdk:"data"`
	Name         types.String `tfsdk:"name"`
	Organization types.String `tfsdk:"organization"`
	Permissions  types.List   `tfsdk:"permissions"`
	Role         types.Int64  `tfsdk:"role"`
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return nil, diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.ObjectValue, was: %T`, attributesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return nil, diags
	}

	linksVal, ok := linksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ObjectValue, was: %T`, linksAttribute))
	}

	relationshipsAttribute, ok := attributes["relationships"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`relationships is missing from object`)

		return nil, diags
	}

	relationshipsVal, ok := relationshipsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`relationships expected to be basetypes.ObjectValue, was: %T`, relationshipsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Attributes:    attributesVal,
		Id:            idVal,
		Links:         linksVal,
		Relationships: relationshipsVal,
		DataType:      typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	attributesAttribute, ok := attributes["attributes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attributes is missing from object`)

		return NewDataValueUnknown(), diags
	}

	attributesVal, ok := attributesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attributes expected to be basetypes.ObjectValue, was: %T`, attributesAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	linksAttribute, ok := attributes["links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`links is missing from object`)

		return NewDataValueUnknown(), diags
	}

	linksVal, ok := linksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`links expected to be basetypes.ObjectValue, was: %T`, linksAttribute))
	}

	relationshipsAttribute, ok := attributes["relationships"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`relationships is missing from object`)

		return NewDataValueUnknown(), diags
	}

	relationshipsVal, ok := relationshipsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`relationships expected to be basetypes.ObjectValue, was: %T`, relationshipsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Attributes:    attributesVal,
		Id:            idVal,
		Links:         linksVal,
		Relationships: relationshipsVal,
		DataType:      typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Attributes    basetypes.ObjectValue `tfsdk:"attributes"`
	Id            basetypes.StringValue `tfsdk:"id"`
	Links         basetypes.ObjectValue `tfsdk:"links"`
	Relationships basetypes.ObjectValue `tfsdk:"relationships"`
	DataType      basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["attributes"] = basetypes.ObjectType{
		AttrTypes: AttributesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["links"] = basetypes.ObjectType{
		AttrTypes: LinksValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["relationships"] = basetypes.ObjectType{
		AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Attributes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attributes"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Links.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["links"] = val

		val, err = v.Relationships.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["relationships"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attributes basetypes.ObjectValue

	if v.Attributes.IsNull() {
		attributes = types.ObjectNull(
			AttributesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Attributes.IsUnknown() {
		attributes = types.ObjectUnknown(
			AttributesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Attributes.IsNull() && !v.Attributes.IsUnknown() {
		attributes = types.ObjectValueMust(
			AttributesValue{}.AttributeTypes(ctx),
			v.Attributes.Attributes(),
		)
	}

	var links basetypes.ObjectValue

	if v.Links.IsNull() {
		links = types.ObjectNull(
			LinksValue{}.AttributeTypes(ctx),
		)
	}

	if v.Links.IsUnknown() {
		links = types.ObjectUnknown(
			LinksValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Links.IsNull() && !v.Links.IsUnknown() {
		links = types.ObjectValueMust(
			LinksValue{}.AttributeTypes(ctx),
			v.Links.Attributes(),
		)
	}

	var relationships basetypes.ObjectValue

	if v.Relationships.IsNull() {
		relationships = types.ObjectNull(
			RelationshipsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Relationships.IsUnknown() {
		relationships = types.ObjectUnknown(
			RelationshipsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Relationships.IsNull() && !v.Relationships.IsUnknown() {
		relationships = types.ObjectValueMust(
			RelationshipsValue{}.AttributeTypes(ctx),
			v.Relationships.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"attributes": basetypes.ObjectType{
			AttrTypes: AttributesValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"links": basetypes.ObjectType{
			AttrTypes: LinksValue{}.AttributeTypes(ctx),
		},
		"relationships": basetypes.ObjectType{
			AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attributes":    attributes,
			"id":            v.Id,
			"links":         links,
			"relationships": relationships,
			"type":          v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Attributes.Equal(other.Attributes) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Links.Equal(other.Links) {
		return false
	}

	if !v.Relationships.Equal(other.Relationships) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attributes": basetypes.ObjectType{
			AttrTypes: AttributesValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"links": basetypes.ObjectType{
			AttrTypes: LinksValue{}.AttributeTypes(ctx),
		},
		"relationships": basetypes.ObjectType{
			AttrTypes: RelationshipsValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttributesType{}

type AttributesType struct {
	basetypes.ObjectType
}

func (t AttributesType) Equal(o attr.Type) bool {
	other, ok := o.(AttributesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttributesType) String() string {
	return "AttributesType"
}

func (t AttributesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttributesValue{
		CreatedAt: createdAtVal,
		Name:      nameVal,
		UpdatedAt: updatedAtVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueNull() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateNull,
	}
}

func NewAttributesValueUnknown() AttributesValue {
	return AttributesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAttributesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttributesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttributesValue Attribute Value",
				"While creating a AttributesValue value, a missing attribute value was detected. "+
					"A AttributesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttributesValue Attribute Type",
				"While creating a AttributesValue value, an invalid attribute value was detected. "+
					"A AttributesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttributesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttributesValue Attribute Value",
				"While creating a AttributesValue value, an extra attribute value was detected. "+
					"A AttributesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttributesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewAttributesValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewAttributesValueUnknown(), diags
	}

	return AttributesValue{
		CreatedAt: createdAtVal,
		Name:      nameVal,
		UpdatedAt: updatedAtVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAttributesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttributesValue {
	object, diags := NewAttributesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttributesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttributesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttributesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttributesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttributesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttributesValueMust(AttributesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AttributesType) ValueType(ctx context.Context) attr.Value {
	return AttributesValue{}
}

var _ basetypes.ObjectValuable = AttributesValue{}

type AttributesValue struct {
	CreatedAt basetypes.StringValue `tfsdk:"created_at"`
	Name      basetypes.StringValue `tfsdk:"name"`
	UpdatedAt basetypes.StringValue `tfsdk:"updated_at"`
	state     attr.ValueState
}

func (v AttributesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttributesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttributesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttributesValue) String() string {
	return "AttributesValue"
}

func (v AttributesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"name":       basetypes.StringType{},
		"updated_at": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at": v.CreatedAt,
			"name":       v.Name,
			"updated_at": v.UpdatedAt,
		})

	return objVal, diags
}

func (v AttributesValue) Equal(o attr.Value) bool {
	other, ok := o.(AttributesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v AttributesValue) Type(ctx context.Context) attr.Type {
	return AttributesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttributesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"name":       basetypes.StringType{},
		"updated_at": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LinksType{}

type LinksType struct {
	basetypes.ObjectType
}

func (t LinksType) Equal(o attr.Type) bool {
	other, ok := o.(LinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinksType) String() string {
	return "LinksType"
}

func (t LinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return nil, diags
	}

	selfVal, ok := selfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.ObjectValue, was: %T`, selfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinksValue{
		Self:  selfVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLinksValueNull() LinksValue {
	return LinksValue{
		state: attr.ValueStateNull,
	}
}

func NewLinksValueUnknown() LinksValue {
	return LinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinksValue Attribute Value",
				"While creating a LinksValue value, a missing attribute value was detected. "+
					"A LinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinksValue Attribute Type",
				"While creating a LinksValue value, an invalid attribute value was detected. "+
					"A LinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinksValue Attribute Value",
				"While creating a LinksValue value, an extra attribute value was detected. "+
					"A LinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	selfAttribute, ok := attributes["self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	selfVal, ok := selfAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self expected to be basetypes.ObjectValue, was: %T`, selfAttribute))
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	return LinksValue{
		Self:  selfVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinksValue {
	object, diags := NewLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinksValueMust(LinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinksType) ValueType(ctx context.Context) attr.Value {
	return LinksValue{}
}

var _ basetypes.ObjectValuable = LinksValue{}

type LinksValue struct {
	Self  basetypes.ObjectValue `tfsdk:"self"`
	state attr.ValueState
}

func (v LinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["self"] = basetypes.ObjectType{
		AttrTypes: SelfValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Self.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["self"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinksValue) String() string {
	return "LinksValue"
}

func (v LinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var self basetypes.ObjectValue

	if v.Self.IsNull() {
		self = types.ObjectNull(
			SelfValue{}.AttributeTypes(ctx),
		)
	}

	if v.Self.IsUnknown() {
		self = types.ObjectUnknown(
			SelfValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Self.IsNull() && !v.Self.IsUnknown() {
		self = types.ObjectValueMust(
			SelfValue{}.AttributeTypes(ctx),
			v.Self.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"self": basetypes.ObjectType{
			AttrTypes: SelfValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"self": self,
		})

	return objVal, diags
}

func (v LinksValue) Equal(o attr.Value) bool {
	other, ok := o.(LinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Self.Equal(other.Self) {
		return false
	}

	return true
}

func (v LinksValue) Type(ctx context.Context) attr.Type {
	return LinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"self": basetypes.ObjectType{
			AttrTypes: SelfValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SelfType{}

type SelfType struct {
	basetypes.ObjectType
}

func (t SelfType) Equal(o attr.Type) bool {
	other, ok := o.(SelfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SelfType) String() string {
	return "SelfType"
}

func (t SelfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	describedbyAttribute, ok := attributes["describedby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`describedby is missing from object`)

		return nil, diags
	}

	describedbyVal, ok := describedbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`describedby expected to be basetypes.StringValue, was: %T`, describedbyAttribute))
	}

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return nil, diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	hreflangAttribute, ok := attributes["hreflang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hreflang is missing from object`)

		return nil, diags
	}

	hreflangVal, ok := hreflangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hreflang expected to be basetypes.StringValue, was: %T`, hreflangAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return nil, diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return nil, diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return nil, diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SelfValue{
		Describedby: describedbyVal,
		Href:        hrefVal,
		Hreflang:    hreflangVal,
		Meta:        metaVal,
		Rel:         relVal,
		Title:       titleVal,
		SelfType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSelfValueNull() SelfValue {
	return SelfValue{
		state: attr.ValueStateNull,
	}
}

func NewSelfValueUnknown() SelfValue {
	return SelfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSelfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SelfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SelfValue Attribute Value",
				"While creating a SelfValue value, a missing attribute value was detected. "+
					"A SelfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SelfValue Attribute Type",
				"While creating a SelfValue value, an invalid attribute value was detected. "+
					"A SelfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SelfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SelfValue Attribute Value",
				"While creating a SelfValue value, an extra attribute value was detected. "+
					"A SelfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SelfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSelfValueUnknown(), diags
	}

	describedbyAttribute, ok := attributes["describedby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`describedby is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	describedbyVal, ok := describedbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`describedby expected to be basetypes.StringValue, was: %T`, describedbyAttribute))
	}

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	hreflangAttribute, ok := attributes["hreflang"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hreflang is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	hreflangVal, ok := hreflangAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hreflang expected to be basetypes.StringValue, was: %T`, hreflangAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	titleAttribute, ok := attributes["title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`title is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	titleVal, ok := titleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`title expected to be basetypes.StringValue, was: %T`, titleAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSelfValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSelfValueUnknown(), diags
	}

	return SelfValue{
		Describedby: describedbyVal,
		Href:        hrefVal,
		Hreflang:    hreflangVal,
		Meta:        metaVal,
		Rel:         relVal,
		Title:       titleVal,
		SelfType:    typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSelfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SelfValue {
	object, diags := NewSelfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSelfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SelfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSelfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSelfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSelfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSelfValueMust(SelfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SelfType) ValueType(ctx context.Context) attr.Value {
	return SelfValue{}
}

var _ basetypes.ObjectValuable = SelfValue{}

type SelfValue struct {
	Describedby basetypes.StringValue `tfsdk:"describedby"`
	Href        basetypes.StringValue `tfsdk:"href"`
	Hreflang    basetypes.StringValue `tfsdk:"hreflang"`
	Meta        basetypes.ObjectValue `tfsdk:"meta"`
	Rel         basetypes.StringValue `tfsdk:"rel"`
	Title       basetypes.StringValue `tfsdk:"title"`
	SelfType    basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v SelfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["describedby"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["href"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hreflang"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["meta"] = basetypes.ObjectType{
		AttrTypes: MetaValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["rel"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["title"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Describedby.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["describedby"] = val

		val, err = v.Href.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["href"] = val

		val, err = v.Hreflang.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hreflang"] = val

		val, err = v.Meta.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["meta"] = val

		val, err = v.Rel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rel"] = val

		val, err = v.Title.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["title"] = val

		val, err = v.SelfType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SelfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SelfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SelfValue) String() string {
	return "SelfValue"
}

func (v SelfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var meta basetypes.ObjectValue

	if v.Meta.IsNull() {
		meta = types.ObjectNull(
			MetaValue{}.AttributeTypes(ctx),
		)
	}

	if v.Meta.IsUnknown() {
		meta = types.ObjectUnknown(
			MetaValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Meta.IsNull() && !v.Meta.IsUnknown() {
		meta = types.ObjectValueMust(
			MetaValue{}.AttributeTypes(ctx),
			v.Meta.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"describedby": basetypes.StringType{},
		"href":        basetypes.StringType{},
		"hreflang":    basetypes.StringType{},
		"meta": basetypes.ObjectType{
			AttrTypes: MetaValue{}.AttributeTypes(ctx),
		},
		"rel":   basetypes.StringType{},
		"title": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"describedby": v.Describedby,
			"href":        v.Href,
			"hreflang":    v.Hreflang,
			"meta":        meta,
			"rel":         v.Rel,
			"title":       v.Title,
			"type":        v.SelfType,
		})

	return objVal, diags
}

func (v SelfValue) Equal(o attr.Value) bool {
	other, ok := o.(SelfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Describedby.Equal(other.Describedby) {
		return false
	}

	if !v.Href.Equal(other.Href) {
		return false
	}

	if !v.Hreflang.Equal(other.Hreflang) {
		return false
	}

	if !v.Meta.Equal(other.Meta) {
		return false
	}

	if !v.Rel.Equal(other.Rel) {
		return false
	}

	if !v.Title.Equal(other.Title) {
		return false
	}

	if !v.SelfType.Equal(other.SelfType) {
		return false
	}

	return true
}

func (v SelfValue) Type(ctx context.Context) attr.Type {
	return SelfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SelfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"describedby": basetypes.StringType{},
		"href":        basetypes.StringType{},
		"hreflang":    basetypes.StringType{},
		"meta": basetypes.ObjectType{
			AttrTypes: MetaValue{}.AttributeTypes(ctx),
		},
		"rel":   basetypes.StringType{},
		"title": basetypes.StringType{},
		"type":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MetaType{}

type MetaType struct {
	basetypes.ObjectType
}

func (t MetaType) Equal(o attr.Type) bool {
	other, ok := o.(MetaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetaType) String() string {
	return "MetaType"
}

func (t MetaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return MetaValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewMetaValueNull() MetaValue {
	return MetaValue{
		state: attr.ValueStateNull,
	}
}

func NewMetaValueUnknown() MetaValue {
	return MetaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetaValue Attribute Value",
				"While creating a MetaValue value, a missing attribute value was detected. "+
					"A MetaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetaValue Attribute Type",
				"While creating a MetaValue value, an invalid attribute value was detected. "+
					"A MetaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetaValue Attribute Value",
				"While creating a MetaValue value, an extra attribute value was detected. "+
					"A MetaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	return MetaValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewMetaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetaValue {
	object, diags := NewMetaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetaValueMust(MetaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetaType) ValueType(ctx context.Context) attr.Value {
	return MetaValue{}
}

var _ basetypes.ObjectValuable = MetaValue{}

type MetaValue struct {
	state attr.ValueState
}

func (v MetaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetaValue) String() string {
	return "MetaValue"
}

func (v MetaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v MetaValue) Equal(o attr.Value) bool {
	other, ok := o.(MetaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v MetaValue) Type(ctx context.Context) attr.Type {
	return MetaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = RelationshipsType{}

type RelationshipsType struct {
	basetypes.ObjectType
}

func (t RelationshipsType) Equal(o attr.Type) bool {
	other, ok := o.(RelationshipsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RelationshipsType) String() string {
	return "RelationshipsType"
}

func (t RelationshipsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	permissionsAttribute, ok := attributes["permissions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permissions is missing from object`)

		return nil, diags
	}

	permissionsVal, ok := permissionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permissions expected to be basetypes.ObjectValue, was: %T`, permissionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RelationshipsValue{
		Permissions: permissionsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRelationshipsValueNull() RelationshipsValue {
	return RelationshipsValue{
		state: attr.ValueStateNull,
	}
}

func NewRelationshipsValueUnknown() RelationshipsValue {
	return RelationshipsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRelationshipsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RelationshipsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RelationshipsValue Attribute Value",
				"While creating a RelationshipsValue value, a missing attribute value was detected. "+
					"A RelationshipsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RelationshipsValue Attribute Type",
				"While creating a RelationshipsValue value, an invalid attribute value was detected. "+
					"A RelationshipsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RelationshipsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RelationshipsValue Attribute Value",
				"While creating a RelationshipsValue value, an extra attribute value was detected. "+
					"A RelationshipsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RelationshipsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRelationshipsValueUnknown(), diags
	}

	permissionsAttribute, ok := attributes["permissions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permissions is missing from object`)

		return NewRelationshipsValueUnknown(), diags
	}

	permissionsVal, ok := permissionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permissions expected to be basetypes.ObjectValue, was: %T`, permissionsAttribute))
	}

	if diags.HasError() {
		return NewRelationshipsValueUnknown(), diags
	}

	return RelationshipsValue{
		Permissions: permissionsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRelationshipsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RelationshipsValue {
	object, diags := NewRelationshipsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRelationshipsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RelationshipsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRelationshipsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRelationshipsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRelationshipsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRelationshipsValueMust(RelationshipsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RelationshipsType) ValueType(ctx context.Context) attr.Value {
	return RelationshipsValue{}
}

var _ basetypes.ObjectValuable = RelationshipsValue{}

type RelationshipsValue struct {
	Permissions basetypes.ObjectValue `tfsdk:"permissions"`
	state       attr.ValueState
}

func (v RelationshipsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["permissions"] = basetypes.ObjectType{
		AttrTypes: PermissionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Permissions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permissions"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RelationshipsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RelationshipsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RelationshipsValue) String() string {
	return "RelationshipsValue"
}

func (v RelationshipsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var permissions basetypes.ObjectValue

	if v.Permissions.IsNull() {
		permissions = types.ObjectNull(
			PermissionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Permissions.IsUnknown() {
		permissions = types.ObjectUnknown(
			PermissionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Permissions.IsNull() && !v.Permissions.IsUnknown() {
		permissions = types.ObjectValueMust(
			PermissionsValue{}.AttributeTypes(ctx),
			v.Permissions.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"permissions": basetypes.ObjectType{
			AttrTypes: PermissionsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"permissions": permissions,
		})

	return objVal, diags
}

func (v RelationshipsValue) Equal(o attr.Value) bool {
	other, ok := o.(RelationshipsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Permissions.Equal(other.Permissions) {
		return false
	}

	return true
}

func (v RelationshipsValue) Type(ctx context.Context) attr.Type {
	return RelationshipsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RelationshipsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"permissions": basetypes.ObjectType{
			AttrTypes: PermissionsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PermissionsType{}

type PermissionsType struct {
	basetypes.ObjectType
}

func (t PermissionsType) Equal(o attr.Type) bool {
	other, ok := o.(PermissionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PermissionsType) String() string {
	return "PermissionsType"
}

func (t PermissionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return nil, diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PermissionsValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPermissionsValueNull() PermissionsValue {
	return PermissionsValue{
		state: attr.ValueStateNull,
	}
}

func NewPermissionsValueUnknown() PermissionsValue {
	return PermissionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPermissionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PermissionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PermissionsValue Attribute Value",
				"While creating a PermissionsValue value, a missing attribute value was detected. "+
					"A PermissionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PermissionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PermissionsValue Attribute Type",
				"While creating a PermissionsValue value, an invalid attribute value was detected. "+
					"A PermissionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PermissionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PermissionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PermissionsValue Attribute Value",
				"While creating a PermissionsValue value, an extra attribute value was detected. "+
					"A PermissionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PermissionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPermissionsValueUnknown(), diags
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return NewPermissionsValueUnknown(), diags
	}

	dataVal, ok := dataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ListValue, was: %T`, dataAttribute))
	}

	if diags.HasError() {
		return NewPermissionsValueUnknown(), diags
	}

	return PermissionsValue{
		Data:  dataVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPermissionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PermissionsValue {
	object, diags := NewPermissionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPermissionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PermissionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPermissionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPermissionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPermissionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPermissionsValueMust(PermissionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PermissionsType) ValueType(ctx context.Context) attr.Value {
	return PermissionsValue{}
}

var _ basetypes.ObjectValuable = PermissionsValue{}

type PermissionsValue struct {
	Data  basetypes.ListValue `tfsdk:"data"`
	state attr.ValueState
}

func (v PermissionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["data"] = basetypes.ListType{
		ElemType: DataValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Data.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PermissionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PermissionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PermissionsValue) String() string {
	return "PermissionsValue"
}

func (v PermissionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	data := types.ListValueMust(
		DataType{
			basetypes.ObjectType{
				AttrTypes: DataValue{}.AttributeTypes(ctx),
			},
		},
		v.Data.Elements(),
	)

	if v.Data.IsNull() {
		data = types.ListNull(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Data.IsUnknown() {
		data = types.ListUnknown(
			DataType{
				basetypes.ObjectType{
					AttrTypes: DataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"data": basetypes.ListType{
			ElemType: DataValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data": data,
		})

	return objVal, diags
}

func (v PermissionsValue) Equal(o attr.Value) bool {
	other, ok := o.(PermissionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Data.Equal(other.Data) {
		return false
	}

	return true
}

func (v PermissionsValue) Type(ctx context.Context) attr.Type {
	return PermissionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PermissionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data": basetypes.ListType{
			ElemType: DataValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDataValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Id:       idVal,
		DataType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Id       basetypes.StringValue `tfsdk:"id"`
	DataType basetypes.StringValue `tfsdk:"type"`
	state    attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.DataType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":   v.Id,
			"type": v.DataType,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.DataType.Equal(other.DataType) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":   basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}
